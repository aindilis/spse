Proceedings of the Twentieth International Conference on Automated Planning and Scheduling (ICAPS 2010)

A New Approach to Conformant Planning using CNF∗
Son Thanh To and Tran Cao Son and Enrico Pontelli
New Mexico State University Dept. of Computer Science sto@cs.nmsu.edu, tson@cs.nmsu.edu, epontell@cs.nmsu.edu

Abstract
In this paper, we develop a heuristic, progression based conformant planner, called C NF, which represents belief states by a special type of CNF formulae, called CNF-state. We deﬁne a transition function ΦCN F for computing the successor belief state resulting from the execution of an action in a belief state and prove that it is sound and complete with respect to the complete semantics deﬁned in the literature for conformant planning. We evaluate the performance of C NF against other state-of-the-art conformant planners and identify the classes of problems where C NF is comparable with other state-of-the-art planners or scales up better than other planners. We also develop a technique called one-of relaxation which helps boost the performance of C NF. We characterize the domains where this technique can be applied and validate this idea by proposing a new set of benchmarks that is really difﬁcult for other planners yet easy for C NF.

Introduction and Motivation
Conformant planning is the planning problem in presence of incomplete information about the initial state. A conformant plan is a sequence of actions that achieves the goal from any possible initial state of the world. For example, given that the execution of an action a changes the value of a proposition f from false to true, regardless of the truth value of other propositions, the sequence containing only the action a is a conformant plan achieving f from any possible state of the world. Conformant planning is important since it removes one of the (unrealistic) assumptions about planning problems: the completeness assumption which states that agent has complete information about the initial state. Since the problem is introduced (Smith and Weld 1998), several conformant planners have been developed. To date, the most efﬁcient conformant planners are Conformant-FF (CFF) (Brafman and Hoffmann 2004), KACMBP (Cimatti, Roveri, and Bertoli 2004), POND (Bryce, Kambhampati, and Smith 2006), t0 (Palacios and Geffner 2007), C PA (Tran et al. 2009), and D NF (To, Pontelli, and Son 2009). One of the major difﬁculties in the building of a conformant planner lies in dealing with the uncertainty about the initial state, which is often represented by a set of formulas
∗ Partial supported by NSF grants IIS-0812267, CBET0754525, and CREST-0420407. Copyright c 2010, Association for the Advancement of Artiﬁcial Intelligence (www.aaai.org). All rights reserved.

describing the possible initial states of the world, which is often referred as the initial belief state. In a domain with n propositions, the size of the initial belief state can be 2n . The representation of belief states affects the performance of a conformant planner in two ways. First, it can quickly increase the memory usage of the planner, leading to the undesirable “Out of memory” situation, if the size of the belief state is large. Second, it directly inﬂuences the time complexity in computing the successor belief states. Indeed, the literature is rich in methods for representing of and dealing with belief states in conformant planners. CFF does not have a direct encoding of the belief states in its search process. Rather, it stores the sequence of actions reaching to the belief states and recomputes the belief states whenever it is necessary. 1 Checking whether an action is executable needs a call to a SAT-solver. POND uses ordered binary decision diagram (OBDD) (Bryant 1992) in its representation and relies on the OBDD-library to compute the successor belief states. A disadvantage of this approach is that the size of the OBDD can be very large—the structure of the OBDD is sensitive to the ordering of variables and the manipulation of the OBDD might require intermediate OBDDs of exponential size. t0 translates a conformant planning problem to a classical planning problem, uses a classical planner (FF) to solve the new problem, and then converts the solutions of the new problem to solutions of the original problem. The size of the initial state (the number of the ﬂuents) in the new problem, however, could be exponential to the size of the original problem if completeness is required. C PA identiﬁes and keeps only a set of approximation states, which guarantees completeness of the planner, in its search for solution; thus reducing the size of the belief states, in many cases, signiﬁcantly. The price C PA has to pay is that the overhead for computing the initial approximation state is sometimes quite signiﬁcant, leading to its inability to start the search process. D NF goes to an extreme by employing an explicit representation of belief states using disjunctive normal form. D NF expands the DNF representation on demand. As such, it can avoid some problems faced by C PA, CFF, or t0 and can solve more problems than these planners (To, Pontelli, and Son 2009).
1 CFF does implement some techniques which help reduce the number of recomputations.

169

It is worth mentioning that regardless of the representation of the belief states, all planners have difﬁculties scaling up when the size of the initial belief state is large. For example, for the coins-21 instance, from the IPC-2006, all planners fail to ﬁnd a solution either because of “out of memory” error or because of “time out.” The initial belief state of this problem contains 1016 states, comparing to the “easy instances” in the same domain such as coins-20, whose initial belief state contains less than 106 possible states, and can be solved by all planners in less than two minutes. The above discussion motivates us to investigate alternative representation of belief states in conformant planning. More precisely, we develop a conformant planner, called C NF, that uses a speciﬁc form of CNF, called CNF-state, to represent belief states. We compare C NF with other planners and our experiments show that the new representation does incur some overhead which cannot be easily overcame. In order to exploit the new representation, we develop a new technique called one-of relaxation and implement it in C NF. This technique helps further reducing the size of the initial belief state, allowing the planner to solve instances which cannot be solved by other planners due to the size of the initial belief state. We provide a characterization of domains in which this technique can be applied and evaluate this idea by proposing a new set of benchmarks that is hard for the other planners yet easy for C NF.

where ⊥ denotes a fail state. Φ is extended to deﬁne Φ, a transition function which maps sequences of actions and belief states to belief states for reasoning about the effects of plans. Let S be a belief state. We say that an action a is executable in a belief state S if it is executable in every state belonging to S. Let αn = [a1 , . . . , an ] be a sequence of actions and αi = [a1 , . . . , ai ]: • If n = 0 then Φ([ ], S) = S; • If n > 0 then ◦ if Φ(αn−1 , S) = ⊥ or an is not executable in Φ(αn−1 , S), then Φ(αn , S) = ⊥; ◦ if Φ(αn−1 , S) = ⊥ and an is executable in Φ(αn−1 , S) then Φ(αn , S) = {Φ(an , s ) | s ∈ Φ(αn−1 , S)}. The initial state of the world I is a belief state and is represented by a formula. In all benchmarks, I is a conjunction of a set of literals, a set of one-of statements (resp. orstatements)—representing an exclusive-or (resp. logical or) of its components. By SI we denote the set of all states satisfying I. Typically, the goal description G can contain literals and or-clauses. A sequence of actions α = [a1 , . . . , an ] is a solution of P if Φ(α, SI ) satisﬁes G. In this paper, for an action a, we will denote with Ca the set of conditional effects of a.

Background: Conformant Planning
A planning problem is a tuple P = F, O, I, G , where F is a set of propositions, O is a set of actions, I describes the initial state of the world, and G describes the goal. A literal is either a proposition p ∈ F or its negation ¬p. ¯ denotes the complement of a literal —i.e., ¯ = ¬ , where ¬¬p=p for p∈F . For a set of literals L, L = { ¯ | ∈ L}. A conjunction of literals is often viewed as the set of its literals. A set of literals X is consistent if there exists no p ∈ F such that {p, ¬p} ⊆ X. A set of literals X is complete if for each p ∈ F , {p, ¬p} ∩ X = ∅. A state s is a consistent and complete set of literals. A belief state is a set of states. We will often use lowercase (resp. uppercase) letter, possibly with indices, to represent a state (resp. a belief state). Each action a in O is associated with a precondition φ (denoted by pre(a)) and a set of conditional effects of the form ψ → (also denoted by a : ψ → ), where φ and ψ are sets of literals and is a literal. A state s satisﬁes a literal , denoted by s |= , if ∈ s. s satisﬁes a conjunction of literals X, denoted by s |= X, if it satisﬁes every literal belonging to X. The satisfaction of a formula in a state is deﬁned in the usual way. Likewise, a belief state S satisﬁes a literal , denoted by S |= , if s |= for every s ∈ S. S satisﬁes a conjunction of literals X, denoted by S |= X, if s |= X for every s ∈ S. Given a state s, an action a is executable in s if s |= pre(a). The effect of executing a in s is e(a, s) = { | ∃(a : ψ → ). s |= ψ} The transition function, denoted by Φ, in the planning domain of P is deﬁned by Φ(a, s) = s \ e(a, s) ∪ e(a, s) s |= pre(a) ⊥ otherwise (1)

Representing Belief States by CNF Formulae
In this section we develop the theoretical basis for the development of a conformant planner which uses a speciﬁc type of CNF formulae, which will be introduced shortly, to represent belief states. Our ﬁrst task is to deﬁne a progression function ΦCN F , similar to the function Φ, for computing the successor belief state. A clause is a set of ﬂuent literals. A clause is trivial if it contains the set {f, ¬f } for some ﬂuent f . A CNF formula is a set of clauses. A literal is in a CNF formula ϕ, denoted by ∈ ϕ, if there exists a clause α ∈ ϕ such that ∈ α. A unit clause is a singleton set, i.e. it contains only one literal. The literal in a unit clause is called unit literal. A clause α subsumes a clause β (or β is subsumed by α) if α ⊂ β. A clause is subsumed by a CNF formula if it is subsumed by some clause in the CNF formula. Obviously, if ϕ is obtained by removing some subsumed clause(s) in a CNF formula ϕ then ϕ ≡ ϕ. Deﬁnition 1. A CNF-formula ϕ is called a CNF-state if • ϕ does not contain a trivial clause; • ϕ does not contain two clauses γ and δ such that γ subsumes δ; and • for every unit clause { } in ϕ, ∈ ϕ. A set of CNF-states is called a CNF-belief state. Intuitively, a CNF-state ϕ is minimal in the sense that it does not contain redundant clauses and can be viewed as a set of states. For example, if F = {p, q}, the CNF-state ϕ1 = {{p}} encodes the set of states in which p is true, i.e., the set {{p, q}, {p, ¬q}}; the CNF-state ϕ2 = {{¬p}} encodes the set of states in which p is false; the set of CNF-states {ϕ1 , ϕ2 } represents all possible states of the domain. Observe also that even though ϕ1 is equivalent to

170

ϕ = {{p}, {p, q}}, ϕ is not a CNF-state as it violates the second condition of Def. 1. Furthermore, observe that a CNF-formula might be represented by several CNF-states. For example, the formula p can be represented by either {{p}} or {{p, q}, {p, ¬q}} 2 . It is easy to see that an arbitrary CNF-formula can be converted into an equivalent CNF-state and there exist different algorithms for this purpose. In C NF, we implemented a ﬁxed-point algorithm which is a modiﬁcation of an effective CNF-preprocessor using unit-propagation and subsumption techniques. The algorithm is deterministic and polynomial in the size of the formula. Furthermore, it yields a CNF-state that cannot be further simpliﬁed using the same techniques. For our discussion, it sufﬁces to note that r(ϕ), the result of the algorithm, is a CNF-state equivalent to ϕ. A literal (resp. a set of literals γ) is true in a CNF-state ϕ if ϕ |= (resp. ϕ |= for every ∈ γ), where |= denotes the standard entailment relation. Also, by ϕ (resp. ϕ ¯) we denote the set of clauses in ϕ which contain (resp. ¯). We deﬁne some operations for the manipulation of CNF formulae, which will be used in manipulating CNF-states. Deﬁnition 2. Let ϕ be a CNF formula and be a literal. By ϕ − we denote the CNF formula obtained by removing from ϕ every occurrence of . E.g., p∧(q∨¬r)−q = p∧¬r and ¬p∧(q∨r)−¬p = q∨r. Deﬁnition 3. For two CNF formulae ϕ = {α1 , . . . , αn } and ψ = {β1 , . . . , βm }, the cross-product of ϕ and ψ, denoted by ϕ × ψ, is the CNF-formula deﬁned by {αi ∪ βj | αi ∈ ϕ, βj ∈ ψ}. If either ϕ or ψ is empty then ϕ × ψ = ∅. Observe that ϕ × ψ is nothing but a transformation of ϕ ∨ ψ to a CNF formula. For a set of CNF formulae Ψ = {ϕ1 , . . . , ϕn }, ×[Ψ] denotes ϕ1 × ϕ2 × . . . × ϕn , a CNFn formula equivalent to i=1 ϕi . Given a CNF-state ϕ, we deﬁne the function Update which encodes the CNF-state after the execution of an action, that causes a literal to be true, in ϕ as follows. Deﬁnition 4. Let ϕ be a CNF-state and a literal. The update of ϕ by , denoted by Update(ϕ, ), is deﬁned by: • If is a unit clause in ϕ then Update(ϕ, ) = ϕ. • If ¯ is a unit clause in ϕ, then Update(ϕ, ) = (ϕ− ¯)∧ . • Otherwise Update(ϕ, ) = r((ϕ\(ϕ ∪ϕ ¯))∧ ∧(ϕ − )×(ϕ ¯− ¯)) Intuitively, Update(ϕ, ) encodes Equation (1) when the set of effects is { } and the action is executable. As ϕ represents a belief state S = {s | s |= ϕ}, Update(ϕ, ) should be equivalent to the formula s∈S (s \ { } ∪ { }). As such, the ﬁrst two cases of Deﬁnition 4 are obvious. To deal with the third case, ﬁrst ϕ is converted to the equivalent formula ϕ = (ϕ0 ∧ (ϕ − ) ∧ (ϕ ¯ − ¯)) ∨ (ϕ0 ∧ (ϕ − ) ∧ ¯) ∨ (ϕ0 ∧ (ϕ ¯ − ¯) ∧ ), where ϕ0 = ϕ \ (ϕ ∪ ϕ ¯). Then ϕ is updated by updating each of its disjuncts: adding to the ﬁrst and updating the last two ones according to the ﬁrst two cases in Deﬁnition 4 (note that the ﬁrst disjunct in ϕ does not contain or ¯, the second contains the unit literal ¯, and the third contains the unit literal ). The formula
2

in the third case is a simpliﬁcation of the obtained formula. The deﬁnition is illustrated in the next few examples: ◦ U pdate({{f }, {g, ¬p}}, p) = {{f }, {p}} ◦ U pdate({{f }, {h, p}}, p) = {{f }, {p}} ◦ U pdate({{f }, {g, ¬p}, {h, p}}, p) = {{f }, {p}, {g, h}} We can prove the following proposition.3 Proposition 1. Given a CNF-state ϕ and two literals 1 and ¯ 2 such that 1 = 2 , then Update(Update(ϕ, 1 ), 2 ) = Update(Update(ϕ, 2 ), 1 ). Proposition 1 shows that the result of updating a CNFstate ϕ using a consistent set of literals L is independent from the order in which the various literals of L are introduced. Given a consistent set of literals L, we denote Update(ϕ, ∅) = ϕ and Update(ϕ, L) = Update(Update(ϕ, ), L \ { }) for any ∈ L if L = ∅. Our goal is now to deﬁne the transition function ΦCN F . Given an action a with the precondition pre(a) and its set of conditional effect Ca and a CNF-state ϕ, we need to deﬁne the successor CNF-state ΦCN F (a, ϕ). Since ϕ is a CNFstate, when computing ΦCN F (a, ϕ), for each ψ → in Ca , there are three cases that need to be considered: (i) ϕ |= ψ; (ii) ϕ |= ¬ψ; and (iii) ϕ |= ψ and ϕ |= ¬ψ. As an example, if ϕ = p ∧ q and ψ = r, then we have ϕ |= ψ and ϕ |= ¬ψ. As such, to deﬁne ΦCN F , we need the following deﬁnition. Deﬁnition 5. Let ϕ be a CNF-state and γ a consistent set of literals. The enabling form of ϕ w.r.t. γ, denoted by ϕ + γ, is a set of CNF formulae and is deﬁned as
ϕ+γ = {ϕ} {r(ϕ ∧ γ), r(ϕ ∧ ¬γ)} if ϕ |= γ or ϕ |= ¬γ otherwise

where ¬γ is the clause γ = {¯ ∈ γ}, ϕ ∧ ¬γ = ϕ ∪ {γ}, l|l and ϕ ∧ γ = ϕ ∪ {{l}|l ∈ γ} It is easy to see that ϕ + γ is a set of CNF formulae such that for every δ ∈ ϕ+γ, δ |= γ or δ |= ¬γ. For a CNF-belief state Ψ, let Ψ + γ = ϕ∈Ψ (ϕ + γ). It holds that Proposition 2. Let ϕ (resp. Ψ) be a CNF-state (resp. CNFbelief state). If γ is a consistent set of literals, then ϕ + γ (resp. Ψ + γ) is a CNF-belief state equivalent to ϕ (resp. Ψ). If γ1 and γ2 are two consistent sets of literals then (ϕ + γ1 ) + γ2 ≡ (ϕ + γ2 ) + γ1 . Deﬁnition 6. Let a be an action with the set of conditional effects Ca . A CNF formula ϕ is called enabling for a if for every conditional effect ψ → in Ca , either ϕ |= ψ or ϕ |= ¬ψ holds. A set of CNF formulae Ψ is enabling for a if every CNF formula in Ψ is enabling for a. For an action a and a CNF-state ϕ, let enba (ϕ) = ((ϕ + ψ1 ) + . . .) + ψk where Ca = {ψ1 → 1 , . . . , ψk → k }. Proposition 3. For every CNF-state ϕ and action a, enba (ϕ) is a CNF-belief state equivalent to ϕ and enabling for a. For an action a and a CNF-state ϕ, the effect of a in ϕ, denoted e(a, ϕ), is deﬁned as follows. e(a, ϕ) = { |ψ → ∈ Ca , ϕ |= ψ}. We are now ready to deﬁne the function ΦCNF .
3 Due to lack of space, all proofs are omitted. They can be found at www.cs.nmsu.edu/~sto/full_cnf_paper.pdf.

In the implementation, actually this will be simpliﬁed to {{p}}

171

Deﬁnition 7. Let ϕ be a CNF-state and let a be an action. By ΦCN F (a, ϕ) we denote the transition function for CNFstates: • ΦCN F (a, ϕ)=r(×[{Update(φ, e(a, φ))|φ∈enba (ϕ)}]) if ϕ |= pre(a); and • ΦCN F (a, ϕ) = ⊥ otherwise. Given a CNF-state ϕ, by BS(ϕ) we denote the belief state consisting of states satisfying ϕ. It holds that Lemma 1. Let φ be a CNF-state enabling an action a. Then, Update(φ, e(a, φ)) ≡ {s \ e(a, s) ∪ e(a, s)|s ∈ BS(φ)} Let ΦCNF is the function deﬁned by extending ΦCNF to allow for reasoning about the effects of an action sequence in the same manner of extending Φ to Φ. Using Lemma 1, one can prove the correctness of the following theorem. Theorem 1. For every CNF state ϕ and action sequence αn , ΦCNF (αn , ϕ) ≡ Φ(αn , BS(ϕ)). The above theorem shows that ΦCNF is equivalent to the complete semantics deﬁned by Φ. Thus, any planner using ΦCNF in its search for solutions will be sound and complete.

m objects o1 , . . . , om , whose initial locations are unknown, and placing them in a trash can. The initial information is speciﬁed by δi = one-of(at(oi , p1 ), . . . , at(oi , pn )). We say that δi = or(at(oi , p1 ), . . . , at(oi , pn )) is a relaxation of the one-of statement δi since the belief state speciﬁed by the or statement contains all states belonging to the belief state speciﬁed by the one-of statement. Let the planning problem P be obtained from the problem dispose(m, n) by replacing δi with δi for every i. Obviously, the size of the CNF-state representing the initial state of dispose(m, n) is much larger than the size of the CNF-state encoding the initial state of P (m × Θ(n2 ) vs. m × n). Moreover, every solution of P is also a solution of dispose(m, n). This can be generalized as follows. = Proposition 5. Let P = F, O, I, G and P F, O, I , G be two conformant problems such that I |= I . If α is a solution of P , then α is also a solution of P . For a CNF-state ϕ and a set ϕ of clauses in ϕ, we have that ϕ |= ϕ . As such, given that the initial belief state is represented by a CNF-state ϕ, the above proposition allows one to attempt to solve the problem with a subset of ϕ. As shown above, this could be signiﬁcant, especially when there are one-of statements that can be replaced by or statements. Deﬁnition 8. Let P = F, O, I, G be a planning problem. We deﬁne Pone-of F, O, Ione-of , G where Ione-of is obtained from I be replacing every one-of( 1 , . . . , n ) in I by or( 1 , . . . , n ). Proposition 5 indicates that if Pone-of has a solution then it is also a solution of P . However, this cannot be applied arbitrarily as shown in the following example. Example 1. Let P = {f, g, h}, {a}, I, G where I = {one-of(f, g, h), one-of(¬f, ¬g)}, a : ¬h → g, and G = {g}. Intuitively, I speciﬁes that ¬h is true in the initial state as the set of states satisfying I contains only two states {f, ¬g, ¬h} and {¬f, g, ¬h}. As such, a solution for this problem is a. It is easy to see that replacing the one-of statements by or statements indiscreetly leads to a new problem that has no solution. The above example shows that one-of relaxation is incomplete. Thus, it is critical to ﬁnd conditions under which the technique can be used and the completeness of the planner is guaranteed. To this end, we formalize the notion of independence of one-of statements. For a one-of/or statement δ, by lit(δ) we denote the set of literals occurring in δ. Deﬁnition 9. A one-of statement δ is independent of • a set of literal S if lit(δ) ∩ S = ∅ and lit(δ) ∩ S = ∅; • an one-of statement (resp. or statement) γ if lit(δ) ∩ lit(γ) = ∅ and lit(δ) ∩ lit(γ) = ∅. • an initial state description I, where δ ∈ I, if δ is independent of every element in I \ {δ}. Intuitively, the independency of an one-of statement δ of I indicates that the literals occurring in δ do not appear in any other statements of I. We also need the next deﬁnition. Deﬁnition 10. Let a be an action and δ be an one-of statement δ, we say

CNF-States and one-of Statements

One of the main methods used in specifying uncertainty in conformant planning benchmarks is the use of the one-of construct. This construct provides a way to specify mutual exclusive information about certain proposition (e.g., a truck t is at one (and only one) place p1 , p2 , p3 is expressed by the statement one-of(at(t, p1 ), at(t, p2 ), at(t, p3 )). The size of the initial belief state (the number of states) depends largely on the number of one-of statements in the problem speciﬁcation. The following proposition discusses this issue. Proposition 4. A one-of statement c can be converted to • an equivalent DNF formula of minimum size of |c|2 ; and • an equivalent CNF formula of minimum size of Θ(|c|2 ). where |c| denotes the number of literals in c. A set S = {c1 , . . . , cn } of independent one-of statements can be converted to an equivalent DNF formula of minimum size Πn |ci |2 and to an equivalent CNF formula of minii=1 mum size Θ(Σn |ci |2 ). i=1 In the above proposition we use independent which will be deﬁned later in the Deﬁnition 9. This proposition shows that the representation of belief state affect the size of the initial belief state, which the planner needs to deal with. This is also the main reason behind the development of the one-of combination technique by C PA which greatly inﬂuences the performance of C PA and D NF. This motivates us to develop an alternative technique to the one-of combination technique for use in the C NF planner. Intuitively, the CNF-representation favors the second way of specifying uncertainty in conformant planning benchmarks, the use of or statements. Can we replace one-of statements by or statements? Surprisingly, in many benchmarks, the answer for this question is yes. We call this technique as one-of relaxation. To illustrate this technique, let us consider the dispose(m, n) problem, one of the benchmarks in IPC-2008. The goal of this problem is to retrieve

172

• a maintains δ if one |pre(a) ∩ lit(δ)| ≤ 1 and for every state s, if s |= δ then Φ(a, s) |= δ. • a negated δ if |pre(a) ∩ lit(δ)| ≤ 1 and for every state s, if s |= δ then Φ(a, s) |= ¯ for every ∈ δ. Intuitively, an action maintains an one-of statement δ if its execution does not change the overall dependency between the literals in δ. In the benchmarks, this type of actions frequently occurs. For instance, the action of driving a truck from one location to another location maintains the one-of statement about the locations of the truck; it also maintains the one-of statements about the locations of other trucks, as it does not affect the location of other trucks. To verify the property of maintainability between actions and one-of statements, we make use of the following lemma. Lemma 2. Let δ = one-of(p1 , . . . , pn ) and a be an action with Ca = {ψ1 → 1 , . . ., ψk → k }. Let γ = {p1 , . . . , pn } and L = { 1 , . . . , k }. a maintains δ if either L ∩ γ = L ∩ γ = ∅; or the following conditions are satisﬁed: ¯ ◦ |L ∩ γ| ≤ 1; and ◦ if i ∈ (L ∩ γ) then γ ∩ (pre(a) ∪ ψi ) = ∅ and ψi → ¯ for every ∈ γ ∩ (pre(a) ∪ ψi ). The above lemma allows us to check, syntactically, the maintainability of an action and one-of statements. A similar lemma can be developed for checking whether an action negates an one-of statement. We can now state a completeness of the problem Pone-of . Theorem 2. Let P be the planning problem F, O, I, G . If • for every one-of statement δ in I, δ is independent of I; • for every action a in O and one-of statement δ in I, a maintains δ or a negates δ; and • G is a conjunction of literals then every solution of P is also a solution of Pone-of . The third condition is important. To see why, consider the statement one-of(f, g) which satisﬁes G = (f ∨ g) ∧ (¬f ∨ ¬g). It is easy to check that or(f, g) does not satisfy G. We observe that many benchmarks in the literature satisfy the conditions of Theorem 2. For example, the coins, dispose domains from the recent IPCs satisfy these property.

(a) enba (ϕ) (b) Ψ = {Update(φ, e(a, φ))|φ ∈ enba (ϕ)} (c) ϕ = ×[Ψ] The algorithms for computing Update(φ, e(a, φ)) and ×[Ψ] are quite straightforward following Def. 4 (for Update), and Def. 3 (for ×) so we omit them here. For the simpliﬁcation of the computation, we implement a preprocessor which combines all effects with the same antecedent into one of the form ψ → η, where η is a set of literals. The algorithm for computing enba (ϕ) is given in Alg. 1. Observe that it also computes e(a, φ) for each φ ∈ enba (ϕ), eliminating some redundant computations. More precisely, the computation in line 7 is done as follows. If φ |= ψ then Z = {φ} and e(a, φ) = e(a, φ) ∪ η; If φ |= ¬ψ then Z = {φ} and e(a, φ) does not change; otherwise, Z = {φ1 , φ2 } where φ1 = r(φ ∧ ψ) and φ2 = r(φ ∧ ¬ψ) with e(a, φ1 ) = e(a, φ) ∪ η and e(a, φ2 ) = e(a, φ). Algorithm 1 Computing enba (ϕ) 1: Input: CNF state ϕ, action a 2: Output: enba (ϕ), e(a, φ) for φ ∈ enba (ϕ) 3: Let X = {ϕ}, e(a, φ) = ∅ for φ ∈ enba (ϕ) 4: for each effect ψ → η in Ca do 5: Let Y = ∅ 6: for each φ ∈ X do 7: compute Z = φ + ψ, update e(a, φ ) for φ ∈ Z 8: Y =Y ∪Z 9: end for 10: Set X = Y 11: end for 12: return X For computing ×[Ψ], we use the following proposition to reduce the amount of computation Proposition 6. Let ϕ and ψ be two CNF formulae, c be a clause in ϕ, and c be a clause in ψ. It holds that • If c = c then r(ϕ × ψ) = r((ϕ \ c) × (ψ \ c ) ∪ c) • If c ⊂ c then r(ϕ × ψ) = r(ϕ × (ψ \ c ) ∪ c ) Observe that if |ϕ| = n (ϕ has n clauses) and |ψ| = m then the ﬁrst item says that the size of the cross-product can be reduced by n + m − 1 clauses. The second item indicates that it can be reduced by n − 1 clauses. Our experiments show that this contributes to a signiﬁcant reduction of search time, ranging between 20% and 90% in the benchmark problems. The main reason is that, without using optimization of Prop. 6, C NF spends most of search time for computing cross-product of CNF-formulae which, if in the same CNFbelief state, usually contains many common clauses since they are originated from the same CNF-formula in the transformation to enabling form. In addition, the Update function creates unit clause(s) which can subsume many other clauses in the CNF-states of the same CNF-belief state.

C NF— A Planner with CNF-States We now describe C NF, a conformant planner which uses CNF-states as the representation of belief states. The planner is a modiﬁcation of D NF. Like other heuristic search based planners, C NF implements a best ﬁrst search algorithm with the following speciﬁcs: each node in the search is a pair of a CNF-state ϕ and the plan p such that ϕ = ΦCNF (p, ϕI ) where ϕI is the initial CNF-state. We omit the search algorithm for space consideration. In what follows, we describe some important considerations, which are different from other planners and contribute to the good performance of C NF.
Computing Successor CNF-States
Given a CNF-state ϕ and an action a with the set of conditional effects Ca , computing the successor CNF-state ϕ = ΦCNF (a, ϕ), by Deﬁnition 7, includes the following steps: 1. If pre(a) is not true in ϕ then ϕ is undeﬁned. 2. If pre(a) is true in ϕ, then ϕ is computed in three steps:

Checking Entailment
Checking whether a CNF-state satisﬁes a set of literals is needed whenever the planner needs to check for the executability condition of an action and the goal satisfaction of CNF-states. It is also needed during the computation of the enabling CNF-belief states. In general, checking whether a literal (resp. set, clause) is true or false in a CNF-state ϕ

173

needs to a call to a SAT-solver. Thus, reducing the number of calls to the SAT-solver is important for the performance of C NF. The representation of belief states as CNF-states provides an easy way to check for entailment in several cases. C NF takes advantages of this fact and reduces the number of calls to the SAT-solver by implementing the following tests before a call to the SAT-solver is made: (i) if ∈ ϕ then ϕ |= ; (ii) if ϕ contains a clause c that subsumes a clause c then ϕ |= c. With this simpliﬁcations, the running time portion of the SAT-solver is manageable for most cases. In our experiment, we observe that it is always less than 3%.

Heuristic
Since C NF is a modiﬁcation of D NF, it uses the number of satisﬁed subgoals to guide its search. However, it does not consider the equivalence of the cardinality heuristic. The reasons for this decision are twofold. By using the number of satisﬁed subgoals, we can evaluate the impact of the belief state representation (using CNF-states) when we compare the performance of C NF and D NF. C NF does not use the cardinality heuristic because of the less the clauses in a CNF-state, the more uncertainty it contains, in general.

Preprocessing Input
C NF is developed by modifying the source code of D NF and C PA. As a result, C NF accepts the same input as D NF and incurs the overhead generated by the preprocessing phase as does D NF. However, C NF does not make use of one-of combination or goal-splitting techniques. C NF makes use of the one-of relaxation technique described in the previous section.

one-of Relaxation

Experimental Evaluation
We evaluate C NF against the following conformant planners: D NF, C PA, CFF, POND, and t0 using conformant planning benchmarks found in the literature. To the best of our knowledge, these planners currently yield the best performance in these domains. We obtained D NF, C PA, and t0, from their respective authors. CFF was downloaded from its author website. We use POND version 1.1.1 with default setting. All the experiments have been carried out using a set of three dedicated Linux workstations of the same conﬁguration: Intel Core 2 Dual 9400 2.66GHz 4GB RAM. The timeout limit is set to 2 hours. The results of our experiments are divided into different tables. In Tables 1, 3, and 4, each column contains the performance of a planner. We report the time and plan length for each planner. ‘OM’, ‘TO’, and ‘F’ denotes out of memory, time out, or abnormal termination of the planner. Due to space limitation, we only report a few large instances of each benchmark and do not report the number of states that are generated and explored by each planner. This number is included in the full version of this paper. In the following, we discuss each table and evaluate the strength and weakness of C NF against other planners.

per are from the author of CFF. The remaining problems including corner-cube (cc-n-m), look-and-grab (lng-n-m-k), and sort-number (sortnum-n) are from the package of t0. The problems in Table 1 share the common property that they do not contain an one-of statement which satisﬁes the relaxation condition. Therefore, C NF can not take the advantage of relaxation technique for these problems. The results show that C NF and D NF are the best on the bomb, cornercube, grip, look-and-grab domains and the performance of these two planners are almost the same on these domains. However, C NF scales up better on corner-cube while D NF is better on look-and-grab. The execution time and length of plans found by C NF and D NF are the same for bomb and gripper. For sort-number, t0 is the best on most instances but only C NF is able to deal with the largest instance. We observe that C NF spends more time in transforming CNFbelief states to CNF-states in this problem while the size of the representation of D NF increases very fast. POND outperforms the others on block and sortnet but its performance is pretty poor on the other domains. CFF is very good at gripper, but it does not scale up well as C NF or D NF does on the larger instances. t0 is the best on raokeys. This planner also performs very well on many small problem instances. Observe that although D NF outperforms all the other planners on small instances of the corner-cube domain but the time increases by a faster rate comparing to C NF. This depends on the number of states generated and explored by D NF and C NF: 24969/5717 v.s. 18321/6362 for corner-cube-40-20 and 300287/62027 v.s. 115330/39283 for corner-cube-119-59, respectively. On the other hand, C NF does not do so good in the utscycle domain due to the explosion of the CNF-state size as shown in Table 5. The overhead of the function × of converting a CNF-belief state to the equivalent CNF-state is another reason. For example, for the instance uts-cycle-3, the real search time (excluding the input theory translation time) is 3.325 seconds. Whereas, the execution time spent on the function × is 3.237, i.e. most of the search time. We present the overhead incurred by C NF for some domains in Table 2. In this table, t_trans, t_search, and t_CN F are the time used by the preprocessing phase (which D NF does also use), the time for searching for a solution, and the time incurs by the transformation of CNF-belief states to CNF-states.

Challenging Problems
Table 3 contains the experimental results with domains that are challenging for current state-of-the-art planners. Among these, coins and dispose (ds-m-n) are from the IPC-2006 and IPC-2008. The others are from the challenging domains proposed in (Palacios and Geffner 2007) including 1-dispose (1d-n-m) and push (push-n-m). Indeed, only few planners can solve these problems and none can scale up when the number of objects/constants become large. For coins-21 and larger instances, the main difﬁculty, which makes these problems challenging, is the huge size of the belief states encountered during the search or the huge size of the initial belief state. The domains in Table 3 fall in the class of problems where

Benchmarks From The Literature
Table 1 contains the results obtained from experiments on the domains block, raokeys (raok-n), and uts-cycle (uts-c-n) from IPC-2008. sortnet is from IPC-2006. bomb and grip-

174

Problem

CNF

DNF

CPA

T0

CFF

POND

Problem

CNF

DNF

CPA

T0

CFF

POND

block-1 0.56/7 0.67/7 0.68/4 0.08/5 0.02/6 0.01/6 block-2 0.83/18 0.68/38 0.76/14 0.2/23 TO 0.06/34 block-3 TO 215/331 OM 48/80 TO 3.9/80 bomb-20-10 0.74/30 0.77/30 3.6/24 F 0.05/30 OM bomb-50-10 1.28/90 1.28/90 21/58 F 1.16/90 OM bomb-100-10 2.7/190 2.7/190 110/110 F 34/190 OM bomb-100-20 5.3/180 5.2/180 244/118 F 28/180 OM cc-20-10 2.37/138 2.07/217 F 2.1/258 2.5k/332 TO cc-40-20 13.4/343 7.75/535 F 87/918 TO TO cc-64-32 49.5/1106 21.2/872 F F TO TO cc-99-49 90.6/1542 89.2/1553 F F TO TO cc-119-59 180/2230 229/3522 F F TO TO gripper-30 3.3/144 3.7/144 17/72 11/118 0.5/174 TO gripper-50 8.6/234 8.7/234 106/106 52/198 3/294 TO gripper-80 22.2/350 22.5/350 432/166 234/318 18/474 TO gripper-100 31.9/438 31.2/438 970/206 421/398 >43 TO lng-4-1-2 1.21/16 1.06/18 1.17/26 27/12 83/105 OM lng-4-2-2 1.22/4 1.33/4 1.38/4 31/4 TO OM lng-4-2-3 2.8/4 3.13/4 3.91/4 141/4 TO OM lng-4-3-3 3.01/4 3.53/4 4.48/4 F TO OM lng-7-2-2 26.4/58 17.9/48 21/28 F TO OM lng-7-3-2 22.9/14 20.8/14 24.7/12 F TO OM raok-2 1.65/27 0.57/26 1.1/32 0.04/21 0.07/34 F raok-3 2754/919 1.68/153 3.8/152 0.25/66 12/102 F raok-4 TO TO TO F TO F sortnet-5 1.2/15 0.94/15 0.94/12 0.26/15 NA 0/12 sortnet-10 21.9/55 1.85/54 3.18/39 OM NA 0.03/38 sortnet-15 257/119 35.9/118 244/65 F NA 0.14/65 sortnum-5 1.56/10 2.57/10 OM 1.92/10 2.9/10 0.49/10 sortnum-6 22.8/15 397/15 OM 18.1/15 TO 19.4/15 sortnum-7 539/21 OM OM 91/21 TO 1077/21 sortnum-8 14277/28 OM OM F TO TO uts-c-3 4.22/3 0.54/3 1.19/3 0.15/3 NA F uts-c-4 TO 0.56/6 18.3/6 0.47/7 NA F uts-c-5 TO 0.73/10 OM 1.8/10 NA F

coins-10 0.6/35 0.62/27 0.9/36 0.04/26 0.12/38 0.5/46 coins-15 0.91/81 0.97/67 7/362 0.12/79 2.6/89 10/124 coins-20 1.15/114 1.41/99 17/105 0.15/107 16/143 105/153 coins-21 1478/7321 OM OM F TO TO coins-25 195/1843 OM OM F TO TO coins-29 999/5368 OM OM F TO TO ds-4-3 0.88/93 1.2/185 4.9/92 0.2/122 0.6/73 55/125 ds-4-5 1.15/155 1.7/180 11.3/126 0.8/145 2.5/107 TO ds-8-3 27.5/392 37.4/447 778/413 133/761 TO OM ds-8-5 32/537 65/878 2152/541 F TO OM ds-10-3 158/531 193/680 4694/648 2388/1360 TO OM ds-10-5 175/840 274/1286 TO F TO TO ds-10-9 222/1543 787/2178 TO F TO TO 1d-3-2 0.74/60 0.78/36 0.76/27 0.9/38 TO 5.8/54 1d-3-3 1.04/60 1.86/36 1.87/27 48/36 TO 77/50 1d-3-4 1.67/60 12.5/36 14.3/27 F TO OM 1d-6-2 10.8/492 15.4/186 33.7/124 F TO OM 1d-6-3 18.1/492 506/186 OM F TO OM 1d-6-4 30.4/492 OM OM F TO OM 1d-10-4 667/3806 OM OM F TO OM 1d-10-5 1240/3806 OM OM F TO OM push-4-1 0.94/41 1.17/41 1.61/51 0.16/78 0.28/46 7.3/65 push-4-3 1.06/105 2.1/194 144/847 0.66/164 1.3/48 TO push-4-5 1.45/145 5.05/331 OM 2.04/260 126/50 OM push-8-1 25.8/163 27.1/163 29.6/169 63/464 TO TO push-8-2 29.6/396 41.2/903 4254/429 F TO TO push-8-3 31.9/303 74/1477 OM F TO TO push10-6 227/1194 2235/6382 OM F TO TO push10-7 259/1221 OM OM F TO TO

Table 1: Benchmarks from Literature the one-of relaxation is applicable. As we can see, C NF outperforms other planners in many challenging domains (dispose, 1-dispose, and push) and shows great performance in the coins domain. In fact, only C NF was able to solve the instances (-21 to -30) of the coins domain. In smaller instances, C NF and D NF are comparable but the high memory usage of D NF results in the “OM” error of D NF in large instances.

Table 3: Challenging Domains and n different places p1 , . . . , pn . The goal is to ﬁnd a plan for a robot to pickup the objects and drop them at a place where a trash can is available. Initially, we don’t have any information about which object at which place. So, in the initial information there are m one-of clauses of following form: one-of(at(oi , p1 ), . . . , at(oi , pn )) for i = 1, . . . , m. The robot can move between places by the actions up, down, lef t, and right; pickup objects at different locations by the action pickup(oi , pj ); hold an object holding(oi ). The new problem, denoted by or-dispose, is as follows. In this new problem, each object is associated with a type, i.e., each oi is an object type, e.g. pens, books ... The predicate at(oi , pj ) now means “there exists an object of type oi at place pj .” Similarly, holding(oi ) means “holding some object(s) of type oi .” The action pickup(oi , pj ) allows the robot to pickup all the objects of type oi at place pj . Suppose, initially, all we know about the objects is that for each object type oi , there is at least one instance of oi lying in some places pj ’s. In effect, we replace the one-of statement one-of(at(oi , p1 ), . . . , at(oi , pn )) by the or statement or(at(oi , p1 ), . . . , at(oi , pn )) in the domain speciﬁcation of dispose. Observe that, when one-of relaxation is applied, the description of the initial state of dispose becomes exactly the same as that of or-dispose. Hence, the size of the CNF state representing the initial belief state does not change from dispose to or-dispose if the one-of relaxation is applied. As

New Challenging Problems
In this subsection, we introduce a new set of problems that play to the advantage of C NF. They are variants of the challenging problems of the problems in Table 3. Instead of one-of statements, we use the or statements. To illustrate the modiﬁcation, let us use the dispose problem. In this problem, there are m different objects o1 , . . . , om
Problem block-1 gripper-30 sortnet-5 uts-c-3 t_trans t_search t_CNF 0.53 1.19 0.85 0.895 0.029 2.11 0.35 3.325 0.013 0.23 0.15 3.237 Problem b-50-10 c-20-40 lng-4-1-2 sortnum-5 t_trans t_search t_CNF 1.01 0.75 0.96 0.613 0.272 1.62 0.25 0.947 0.032 0.83 0.11 0.682

Table 2: Time Distribution: Search vs. Translation vs. Transformation in C NF

175

Problem

CNF

DNF

CPA

T0

CFF

POND

Problem block-1 block-2 bomb-m-n uts-c-3

Init./Avg. 47/39 105/145 0/0 132/2820

Problem cc-99-49 cc-119-59 lng-4-3-3 lng-7-3-2

Init./Avg. 12/6 12/6 768/57 4802/134

Problem sortnet-10 sortnet-15 sortnum-5 sortnum-7

Init./Avg. 0/43 0/87 0/28 0/102

or-coins-10 0.65/35 OM OM 0.032/26 0.11/38 0.5/46 or-coins-20 1.1/114 OM OM 0.15/107 15.9/143 86/121 or-coins-21 1486/7321 OM OM F TO TO or-ds-4-3 0.86/93 81/117 OM 0.26/122 0.46/73 63.6/126 or-ds-4-5 1.15/155 OM OM 1.15/145 1.9/107 OM or-ds-8-3 27.85/392 OM OM 278/761 TO OM or-ds-8-5 31.9/537 OM OM F TO OM or-ds-10-9 222/1543 OM OM F TO OM or-1d-3-2 0.74/60 1.15/32 OM F TO 6.17/50 or-1d-3-4 1.67/60 420/32 OM F TO OM or-1d-6-2 10.8/492 190/150 OM F TO OM or-1d-6-3 18.1/492 OM OM F TO OM or-1d-10-5 1240/3806 OM OM F TO OM or-push-4-1 0.94/41 0.83/61 52/49 0.38/78 0.26/46 1.86/65 or-push-4-3 1.06/105 115/147 OM 11/189 0.8/48 125/120 or-push-8-1 26.6/163 27.2/134 OM 2.8k/367 TO TO or-push-8-2 29.8/396 OM OM TO TO TO or-push-10-7 259/1221 OM OM TO TO TO

Table 5: Size of CNF-states: Initial vs. Average
Problem coins-20 coins-22 1d-3-3 1d-6-2 Relaxation 54/28 170/45 27/26 72/25 No Relax. 402/200 1.7k/1.3k 243/446 2592/511 Probem ds-8-5 ds-10-3 push-4-5 push-8-3 Relaxation 320/121 300/99 80/22 192/64 No Relax. 20k/4.7k 30k/5.7k 1280/165 12k/203

Table 4: New Challenging Domains such, C NF will be able to solve the new problems without difﬁculty. The new set of problems contains also the or-version of other problems such as or-coins, or-dispose, or-1-dispose, and or-push. Table 4 displays the results of all planners on the set of new problems. Due to the extremely large size of disjunctive normal form formulae representing belief states in these problems, a DNF belief state representation based planner, e.g. D NF and C PA, appears to have very poor performance on these problems. In these problems, the one-of combination technique is not applicable and therefore D NF and C PA perform poorly on these problems. On the contrary, due to the capability of maintaining a compact size of CNF formulae representing belief states, C NF outperforms impressively not only DNF belief state representation based planners, but also all other competitive state-of-the-art conformant planners. It is worth mentioning that there is no signiﬁcant difference between the performance of any other planner on these problems in comparison with that on the original problems.

Table 6: Size of CNF-states: Applying Relax. vs. Not Applying other state-of-the-art conformant planners in many domains. More importantly, the new planner provides a better scalability than all other planners; it can solve larger instances of many problems that were challenging to previous conformant planners. We propose a new technique, called one-of relaxation, aimed at reducing the size of the initial belief state. We also propose a new set of benchmarks that provides new challenges to conformant planners. Although C NF displays good performance, it does have some weaknesses which need to be addressed. First of all, the overhead incurred in the computation of the × function is sometimes larger than the actual time spent for searching for a solution. Furthermore, an improved heuristic is also desirable. Finally, the performance of C NF and D NF suggests that a combination of the two techniques into one planner might yield interesting result.

References
Brafman, R., and Hoffmann, J. 2004. Conformant planning via heuristic forward search: A new approach. In ICAPS, 355–364. Bryant, R. E. 1992. Symbolic boolean manipulation with ordered binary decision diagrams. ACM Computing Surveys 24(3):293–318. Bryce, D.; Kambhampati, S.; and Smith, D. 2006. Planning Graph Heuristics for Belief Space Search. JAIR 26:35–99. Cimatti, A.; Roveri, M.; and Bertoli, P. 2004. Conformant Planning via Symbolic Model Checking and Heuristic Search. AIJ 159:127–206. Palacios, H., and Geffner, H. 2007. From Conformant into Classical Planning: Efﬁcient Translations that may be Complete Too. In ICAPS. Smith, D., and Weld, D. 1998. Conformant graphplan. In AAAI, 889–896. To, S. T.; Pontelli, E.; and Son, T. C. 2009. A Conformant Planner with Explicit Disjunctive Representation of Belief States. In Proceedings of the 19th International Conference on Planning and Scheduling (ICAPS). Tran, D.-V.; Nguyen, H.-K.; Pontelli, E.; and Son, T. C. 2009. Improving performance of conformant planners: Static analysis of declarative planning domain speciﬁcations. In PADL, LNCS 5418, 239–253. Springer.

Size of CNF-states
We deﬁne the size of a CNF-state the total of the size of every non-unit clause in the CNF-state. The experiments reveal that the size of successor CNF-states keep decreasing in most problems. The reason is that updating a CNF-state by a literal removes all the clauses containing or ¯. On the other hand, most clauses in (ϕ − ) × (ϕ ¯ − ¯) are usually trivial or subsumed by another clause in the formula. Tables 5 and 6 report the size of the initial CNF-state and the average size of the generated CNF-states for several instances. Table 6 also shows the effectiveness of the one-of relaxation by additionally reporting those sizes for some problems in Table 3 when the one-of relaxation is not used.

Conclusion and Future Work
In this paper, we introduce a new conformant planner, C NF, which uses a special type of CNF formulae to represent belief states. The overall performance of C NF on several benchmark problems shows that it is competitive with

176


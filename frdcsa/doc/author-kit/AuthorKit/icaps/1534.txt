Proceedings of the Twentieth International Conference on Automated Planning and Scheduling (ICAPS 2010)

Classical Planning in MDP Heuristics: With a Little Help from Generalization
Andrey Kolobov
{akolobov, mausam, weld}@cs.washington.edu Dept of Computer Science and Engineering University of Washington, Seattle WA-98195

Mausam

Daniel S. Weld

Abstract
Heuristic functions make MDP solvers practical by reducing their time and memory requirements. Some of the most effective heuristics (e.g., the FF heuristic function) ﬁrst determinize the MDP and then solve a relaxation of the resulting classical planning problem (e.g., by ignoring delete effects). While these heuristic functions are fast to compute, they frequently yield overly optimistic value estimates. It is natural to wonder, then, whether the improved estimates of using a full classical planner on the (non-relaxed) determinized domain will provide enough gains to compensate for the vastly increased cost of computation. This paper shows that the answer is “No and Yes”. If one uses a full classical planner in the obvious way, the cost of the heuristic function’s computation outweighs the beneﬁts. However, we show that one can make the idea practical by generalizing the results of classical planning successes and failures. Speciﬁcally, we introduce a novel heuristic function called GOTH that amortizes the cost of classical planning by 1) extracting basis functions from the plans discovered during heuristic computation, 2) using these basis functions to generalize the heuristic value of one state to cover many others, and 3) thus invoking the classical planner many fewer times than there are states. Experiments show that GOTH can provide vast time and memory savings compared to the FF heuristic function — especially on large problems.

Introduction
Heuristic functions, or heuristics, for short, are a popular means of reducing space and memory requirements of state space search-based probabilistic planning algorithms. In MDP solvers guided by heuristic functions, e.g. LRTDP (Bonet and Geffner 2003) and LAO∗ (Hansen and Zilberstein 2001), heuristics help avoid visiting many states (and memoizing corresponding state-value pairs) that are not part of the ﬁnal policy. While there are many ways of constructing a good heuristic for probabilistic domains, some of the most effective ones are derived from classical planning analogs. A notable example is the FF heuristic (Hoffman and Nebel 2001), denoted hF F in this paper, which calculates the value of a state in three conceptual steps: (1) determinizing the probabilistic MDP actions into a set of classical actions, (2) relaxing
Copyright c 2010, Association for the Advancement of Artiﬁcial Intelligence (www.aaai.org). All rights reserved.

the domain further by eliminating the delete lists of all actions, and (3) ﬁnding the cost of the cheapest sequence of these modiﬁed actions to the goal using a relaxed planning graph. This cost is taken as the heuristic value of the state in the original probabilistic problem. Although efﬁciently computable and quite informative, it is liable to highly underestimate the state’s true value because of multiple levels of relaxation: once due to determinization and once more due to ignoring delete effects. On the other hand, a lot of promise has been shown recently by several probabilistic planners that solve full (nonrelaxed) determinizations, e.g., FF-Replan (Yoon, Fern, and Givan 2007), HMDPP (Keyder and Geffner 2008), and others. It is natural to wonder, then, whether the improved heuristic estimates of using a full classical planner on the non-relaxed determinized domain would provide enough gains to compensate for the potentially increased cost of heuristic computation. As we show in this paper, the answer is “No and Yes”. We propose a new heuristic called GOTH (Generalization Of Trajectories Heuristic), which efﬁciently produces heuristic state values using deterministic planning. The most straightforward implementation of this method, in which a classical planner is called every time a state is visited for the ﬁrst time, does produce better heuristic estimates and reduces search but the cost of so many calls to the classical planner vastly outweighs any beneﬁts. The novelty of our work is in showing that there is a way to amortize these expensive planner calls by generalizing the resulting heuristic values to provide guidance on similar states. We adapt the idea of generalization from a recent planner, ReTrASE (Kolobov, Mausam, and Weld 2009), although there it is used in a somewhat ad hoc search procedure, whereas we employ it for a heuristic computation that guides a principled decision-theoretic search algorithm. By performing this generalization in a careful manner, one may dramatically reduce the amount of classical planning needed, while still providing more informative heuristic values than heuristics with more levels of relaxation. GOTH performs extremely well, especially on large problems. The rest of the paper explains this idea in more detail, focusing on the generalization process. Speciﬁcally, we make the following contributions: • We describe the approach of using non-relaxed determinization for computing the heuristic. With its naive im-

97

plementation we obtain much more informative heuristic values but at a large performance loss. • We apply a generalization procedure to amortize the classical planner invocations leading to a very efﬁcient procedure for heuristic computation. We implement it over miniGPT’s version of labeled RTDP (Bonet and Geffner 2005), and empirically demonstrate that this new approach can be hundreds of times faster than the naive one with very little sacriﬁce in heuristic quality. Thus, we show generalization to be key to GOTH’s time efﬁciency. • We experimentally compare our GOTH implementation against hF F , a state of the art heuristic for probabilistic planning. Our results show that for large problems in ﬁve out of six benchmark domains we massively outperform hF F in terms of memory requirements, attesting to GOTH’s higher informativeness, as well as time efﬁciency. We ﬁnd that LRTDP+hF F exhausts memory on several problems that LRTDP+GOTH is able to solve easily. Additionally, our solution quality is never worse and often better than LRTDP+hF F .

Background
Markov Decision Processes (MDPs). In this paper, we focus on probabilistic planning problems that are modeled by factored indeﬁnite-horizon MDPs. They are deﬁned as tuples of the form S, A, T , C, G, s0 , where S is a ﬁnite set of states, A is a ﬁnite set of actions, T is a transition function S × A × S → [0, 1] giving the probability of moving from si to sj by executing a, C is a map S × A → R+ specifying action costs, s0 is the start state, and G is a set of (absorbing) goal states. Indeﬁnite horizon refers to the fact that the total action cost is accumulated over a ﬁnite-length action sequence whose length is unknown. In this paper, we assume that all actions have conjunctive preconditions, since the disjunctive ones can be compiled away, with the number of actions in the resulting domain increasing linearly in the number of disjuncts. In factored MDPs, each state is represented as a conjunction of values of the domain variables. Solving an MDP means ﬁnding a good (i.e. cost-minimizing) policy π : S → A that speciﬁes the actions the agent should take to eventually reach the goal. The optimal expected cost of reaching the goal from a state s satisﬁes the following conditions, called Bellman equations: V ∗ (s) V (s)
∗

in the trial path using Bellman backups. A popular variant, LRTDP, adds a termination condition to RTDP by labeling those states whose values have converged as ‘solved’ (Bonet and Geffner 2003). Compared to VI, trial-based methods save space by considering fewer irrelevant states. LRTDP serves as the testbed in our experiments, but the approach we present can be used by many other search-based MDP solvers as well, e.g., LAO∗ . Heuristic Functions. We deﬁne a heuristic function, hereafter termed simply as heuristic, as a value function used to initialize the state values before the ﬁrst time an algorithm updates these values. In heuristic-guided algorithms, heuristics help avoid visiting irrelevant states. To guarantee convergence to an optimal policy, MDP solvers require a heuristic to be admissible, i.e. to never overestimate the optimal value of a state (importantly, admissibility is not a requirement for convergence to a policy). However, inadmissible heuristics tend to be more informative in practice, approximating V ∗ better on average. Informativeness often translates into a smaller number of explored states (and the associated memory savings) with reasonable sacriﬁces in optimality. In this paper, we strive to obtain an informative heuristic even at the cost of admissibility, and adopt the number of states visited by a planner under the guidance of a heuristic as the measure of that heuristic’s informativeness. Determinization. Some of the most effective domainindependent heuristics known today are based on determinizing the probabilistic domain at hand. Determinizing domain D removes the uncertainty about D’s action outcomes in a variety of ways. For example, the alloutcomes determinization, for each action a with precondition c and outcomes o1 , . . . , on with respective probabilities p1 , . . . , pn , produces a set of deterministic actions a1 , . . . , an , each with precondition c and effect oi , yielding a classical domain Dd . To obtain a value for state s in D, determinization heuristics try to approximate the cost of a plan from s to a goal in Dd (ﬁnding a plan itself is generally NP-hard). For instance, hF F ignores the delete effects of all actions in Dd and attempts to ﬁnd the cost of the cheapest solution to this new relaxed problem.

GOTH Heuristic
Given a problem P over a probabilistic domain D, the MDP solver using GOTH starts with GOTH’s initialization. During initialization, GOTH determinizes D into its classic counterpart, Dd (this operation needs to be done only once). Our implementation performs the all-outcomes determinization because it is likely to give much better value estimates than the single-outcome one (Yoon, Fern, and Givan 2007). However, more involved ﬂavors of determinization described in the Related Work section may yield even better estimation accuracy. Calling a Deterministic Planner. Once Dd has been computed, the probabilistic planner starts exploring the state space. For every state s that requires a heuristic initialization, GOTH ﬁrst checks if it is an explicit dead end, i.e. has no actions applicable in it. This check is in place for efﬁciency, since GOTH should not spend time on them. For state s that isn’t an explicit dead end GOTH constructs a problem Ps with the original problem’s goal and

= =

0 if s ∈ G, otherwise min[C(s, a) +
a∈A s ∈S

T (s, a, s )V ∗ (s )]

Given V ∗ (s), an optimal policy may be computed as follows: π ∗ (s) = argmina∈A [C(s, a) + ∗ s ∈S T (s, a, s )V (s )]. Solution Methods. The above equations suggest a dynamic programming-based way of ﬁnding an optimal policy, called value iteration (VI), that iteratively updates state values using Bellman equations in a Bellman backup and follows the resulting policy until the values converge. VI has given rise to many improvements. Trial-based methods, e.g. RTDP, try to reach the goal multiple times (in multiple trials) and update the value function over the states

98

Algorithm 1 GOTH Heuristic 1: Input: probabilistic domain D, problem P = init. state s0 , goal G , determinization routine Det, classical planner DetP lan, timeout T , state s 2: Output: heuristic value of s
3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: 29: 30: 31: 32: 33: 34: 35: 36: 37:

compute global determinization Dd = Det(D) declare global map M from basis functions to weights function computeGOTH(state s, timeout T ) if no action a of D is applicable in s then return a large penalty // e.g., 1000000 else if a nogood holds in s then return a large penalty // e.g., 1000000 else if some member f of M holds in s then return minbasis functions f that subsume s {M [f ]} else declare problem Ps ← init. state s, goal G declare plan pl ← DetP lan(Dd , Ps , T ) if pl == none then return a large penalty // e.g., 1000000 else declare basis function f ← goal G declare weight ← 0 for all i = length(pl) through 1 do declare action a ← pl[i] weight ← weight + Cost(s, a) f ← (f ∪ precond(a)) − ef f ect(a) if f is not in M then insert f, weight into M else update M [f ] by incorporating weight into M [f ]’s running average end if end for if SchedulerSaysYes then learn nogoods from discovered dead ends end if return weight end if end if

s as the initial state, feeding Ps along with Dd to a classical planner DetP lan, and setting a timeout (in our setup, 25 seconds). If s is an implicit dead end (i.e., has actions applicable in it but no plan to the goal), DetP lan either quickly proves this or unsuccessfully searches for a plan until the timeout. In either case, it returns without a plan, at which point s is presumed to be a dead end and assigned a very high value. If s is not a dead end, DetP lan usually returns a plan from s to the goal. The cost of this plan is taken as the heuristic value of s. In rare cases, DetP lan may fail to ﬁnd a plan before the timeout, leading the MDP solver to falsely assume s to be a dead end. In practice, we haven’t seen this hurt GOTH’s performance. Regression-Based Generalization. By using a full-ﬂedged classical planner, GOTH produces more informative state estimates than hF F , as evidenced by our experiments. However, invoking the classical planner for every newly encountered state is costly; as it stands, GOTH would be pro-

hibitively slow. To ensure speed, we modify the procedure based on the following insight. Regressing a successful deterministic plan in domain Dd yields a set of literal conjunctions with an important property: each such conjunction is a precondition for the plan sufﬁx that was regressed to generate it. We call these conjunctions basis functions, and deﬁne the weight of a basis function to be the cost of the plan it enables. Crucially, every deterministic plan in Dd corresponds to a positive-probability trajectory in the original domain D; therefore, a basis function is a certiﬁcate of such a trajectory. Every state subsumed by a given basis function is thus proved to have a possible trajectory to the goal. We make this process concrete in the pseudocode of Algorithm 1. Whenever GOTH computes a deterministic plan, it regresses it and caches the resulting basis functions with associated weights. When GOTH encounters a new state s, it minimizes over the weights of all basis functions stored so far that subsume s. In doing so, GOTH sets the heuristic value of s to be the cost of the cheapest currently known trajectory that originates at s. Thus, the weight of one basis function can become generalized as the heuristic value of many states. This way of computing a state’s value is very fast, and GOTH employs it before invoking a classical planner. However, by the time state s needs to be evaluated GOTH may have no basis functions that subsume it. In this case, GOTH uses the classical planner as described above, computing a value for s and augmenting its basis function set. Evaluating a state ﬁrst by generalization and then, if generalization fails, by classical planning greatly amortizes the cost of each classical solver invocation and drastically reduces the computation time compared to using a deterministic planner alone. Weight Updates. Different invocations of the deterministic planner occasionally yield the same basis function more than once, each time potentially with a new weight. Which of these weights should we use? The different weights are caused by a variety of factors, not the least of which are nondeterministic choices made within the classical planner. For instance, LPG (Gerevini, Saetti, and Serina 2003), which relies on a stochastic local search strategy for action selection, may produce distinct paths to the goal even when invoked twice from the same state, with concomitant differences in basis functions and/or their weights. Thus, the basis function weight from any given invocation may be irrepresentative of the cost of the plans for which this basis function is a precondition. For this reason, it is generally beneﬁcial to assign a basis function the average of the weights computed for it by classical planner invocations so far. This is the approach we take on line 27 of Algorithm 1. Note that to compute the average we need to keep the number of times the function has been re-discovered. Dealing with Implicit Dead Ends. The discussion so far has ignored an important detail. When a classical planner is called on an implicit dead end, by deﬁnition no trajectory is discovered, and hence no basis functions. Thus, this invocation is seemingly wasted from the point of view of generalization: it does not contribute to reducing the average cost of heuristic computation. Fortunately, we can, in fact, amortize the cost of discovery of implicit dead ends in a way similar to reducing the average time of other states’ evaluation. For this purpose,

99

we compute conjunctions of literals called nogoods with the property that all states subsumed by a nogood are dead-ends. Just like basis functions guarantee the existence of a goal trajectory from any states they subsume, nogoods guarantee its non-existence. The algorithm for nogood construction and deciding when to perform it, SixthSense (Kolobov, Mausam, and Weld 2010), is rather involved theoretically but very fast. SixthSense includes a scheduler that decides when learning should be attempted. Crucially, when the decision has been made (situation represented in line 30 of Algorithm 1), the technique makes use of the basis functions and implicit dead ends discovered so far, utilizing both as training data to induce nogoods (details are abstracted away in line 31). The produced nogoods are sound (Kolobov, Mausam, and Weld 2010), i.e. all the states each of them subsumes are implicit dead ends. With nogoods available, deciding whether a state is a dead end is as simple as checking whether any of the known nogoods subsume it (lines 8-9 of Algorithm 1). Only if none do may deterministic planning be necessary to answer the question. Experiments indicate (Kolobov, Mausam, and Weld 2010) that SixthSense significantly reduces the amount of resources GOTH uses. For instance, when GOTH is used with LRTDP, SixthSense can help reduce the running time and memory use (since most implicit dead ends don’t need to be memoized anymore) of the combination by 50% and more. Speed and Memory Performance. To facilitate empirical analysis of GOTH, it is helpful to look at the extra speed and memory cost an MDP solver incurs while using it. Concerning GOTH’s memory utilization, we emphasize that, similar to hF F and many other heuristics, GOTH does not store any of the states it is given for evaluation. It merely returns heuristic values of these states to the MDP solver, which can then choose to store the resulting state-value pairs or discard them. However, to compute the values, GOTH needs to memoize the basis function and nogoods it has extracted so far. As our experiments demonstrate, the set of basis functions and nogoods discovered by GOTH throughout the MDP solver’s running time is rather small and is more than compensated for by the reduction in the explored fraction of the state space due to GOTH’s informativeness, compared to hF F . Timewise, GOTH’s performance is largely determined by the speed of the employed deterministic planner(s) and the number of times it is invoked. Another component that may become signiﬁcant is determining the “cheapest” basis function that holds in a state (line 11 of Algorithm 1), as it requires iterating, on average, over a constant fraction of known basis function. Although faster solutions are possible for this pattern-matching problem, all that we are aware of (e.g., (Forgy 1982)) pay for the increase in speed with degraded memory performance. Theoretical properties. Two especially noteworthy theoretical properties of GOTH are the informativeness of its estimates and its inadmissibility. The former ensures that, compared to hF F , GOTH causes MDP solvers to explore fewer states. At the same time, just like hF F , GOTH is inadmissible, but for different reasons. One source of inadmissibility comes from the general lack of optimality of deterministic planners. Even if they were optimal, however, employing timeouts to terminate the classical planner occa-

sionally causes GOTH to falsely assume states to be dead ends. Finally, the basis function generalization mechanism also contributes to inadmissibility. The set of discovered basis functions is almost never complete, and hence even the smallest basis function weight known so far may be an overestimate of a state’s true value, as there may exist an even cheaper goal trajectory from this state that GOTH is unaware of. In spite of theoretical inadmissibility, in practice using GOTH usually yields very good policies whose quality is often better than of those found under the guidance of hF F .

Experimental Results
Our experiments compare the performance of a probabilistic planner using GOTH to that of the same planner under the guidance of hF F across a wide range of domains. In our experience, hF F , included as a part of miniGPT (Bonet and Geffner 2005), outperforms all other well-known MDP heuristics on most IPPC domains, e.g., the min-min and atom-min heuristics supplied in the same package. Our implementation of GOTH uses a portfolio of two classical planners, FF and LPG (Gerevini, Saetti, and Serina 2003). To evaluate a state, it launches both planners as in line 12 of Algorithm 1 in parallel and takes the heuristic value from the one that returns sooner. We tested GOTH and hF F as a part of the LRTDP planner available in the miniGPT package. Our benchmarks were six probabilistic domains, ﬁve of which come from the two most recent IPPCs: Machine Shop (Mausam, Bertoli, and Weld 2007), Triangle Tireworld (IPPC-08), Exploding Blocks World (IPPC-08 version), Blocks World (IPPC-06 version), Elevators (IPPC06), and Drive (IPPC-06). All of the remaining domains from IPPC-06 and IPPC-08 are either easier versions of the above (e.g., Tireworld from IPPC-06) or have features not supported by our implementation of LRTDP (e.g., rewards, universal quantiﬁcation, etc.) so we weren’t able to test on them. Additionally, we perform a brief comparison of LRTDP+GOTH against ReTrASE (Kolobov, Mausam, and Weld 2009) and FF-Replan (Yoon, Fern, and Givan 2007), since these share some insights with GOTH. In all experiments except measuring the effect of generalization, the planners had a 24-hour limit to solve each problem. Comparison against hF F . In this subsection, we use each of the domains to illustrate various aspects and modes of GOTH’s behavior and compare it to the behavior of hF F . As shown below, on ﬁve of the six test domains LRTDP+GOTH massively outperforms LRTDP+hF F . We start the comparison by looking at a domain whose structure is especially inconvenient for hF F . The Machine Shop domain involves two machines and a number of objects equal to the ordinal of the corresponding problem. Each object needs to go through a series of manipulations, of which each machine is able to do only a subset. The effects of some manipulations may cancel the effects of others (e.g., shaping an object destroys the paint sprayed on it). Thus, the order of actions in a plan is critical. This domain illuminates the drawbacks of hF F , which ignores delete effects and doesn’t distinguish good and bad action sequences as a result. Machine Shop has no dead ends. Figures 1 and 2 show the speed and memory performance of LRTDP equipped with the two heuristics. As implied by

100

TIME IN SECONDS

TIME IN SECONDS

1000 800 600 400 200 0 1 2 3 4 5 6 7 8 9 MACHINE SHOP PROBLEM # 10 hFF GOTH
TIME IN SECONDS

4 3 2 1

x 10

4

10000 8000 6000 4000 2000 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 BLOCKSWORLD PROBLEM # hFF GOTH

hFF GOTH

0 1

2

3 4 5 6 7 8 9 TRIANGLE TIRE PROBLEM #

10

Figure 1: GOTH outperforms hF F on Machine Shop, Triangle Tireworld, and Blocksworld by a large margin both in speed...
#STATES+BASIS FUNCS #STATES+BASIS FUNCS

10 8 6 4 2

x 10

10 8 6 4 2

x 10

#STATES+BASIS FUNCS

5

6

3 2 1

x 10

4

hFF GOTH

hFF GOTH

hFF GOTH

0 1

2

3 4 5 6 7 8 9 MACHINE SHOP PROBLEM #

10

0 1

2

3 4 5 6 7 8 9 TRIANGLE TIRE PROBLEM #

10

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 BLOCKSWORLD PROBLEM #

Figure 2: ... and in memory the previous discussion of GOTH’s space requirements, the memory consumption of LRTDP+GOTH is measured by the number of states, basis functions, and nogoods whose values need to be maintained (GOTH caches basis functions and LRTDP caches states). In the case of LRTDP+hF F all memory used is only due to LRTDP’s state caching because hF F by itself does not memoize anything. On Machine Shop, the edge of LRTDP+GOTH is clearly vast, reaching several orders of magnitude. In fact, LRTDP+hF F runs out of memory on the three hardest problems, whereas LRTDP+GOTH is far from that. Concerning the policy quality, we found the use of GOTH to yield optimal or near-optimal policies on Machine Shop. This contrasts with hF F whose policies were on average 30% more costly than the optimal ones. The Triangle Tireworld domain, unlike Machine Shop, doesn’t have structure that is particularly adversarial for hF F . However, LRTDP+GOTH noticeably outperforms LRTDP+hF F on it too, as Figures 1 and 2 indicate. Nonetheless, neither heuristic saves enough memory to let LRTDP solve past problem 8. The results on Exploding Blocks World (EBW) are similar to those on Triangle Tireworld, where the LRTDP+GOTH’s more economical memory consumption eventually translates to a speed advantage. Importantly, however, on several EBW problems LRTDP+GOTH is superior to LRTDP+hF F in a more illustrative way: it manages to solve four problems on which LRTDP+hF F runs out of space. The Drive domain is small, and using GOTH on it may be an overkill. On Drive problems, planners spend most of the time in decision-theoretic computation but explore no more than around 2000 states. LRTDP under the guidance of GOTH and hF F explores roughly the same number of states, but since so few of them are explored generalization does not play a big role and GOTH incurs the additional overhead of maintaining the basis functions without getting a signiﬁcant beneﬁt from them. On the remaining test domains, Elevators and Blocksworld, LRTDP+GOTH dominates LRTDP+hF F in both speed and memory while providing policies of equal or better quality. Figures 1 and 2 shows the performance on Blocksworld as an example. Classical planners in our portfolio cope with determinized versions of these domains very quickly, and generalization ensures that the obtained heuristic values are spread over many states. Similar to the situation on EBW, the effectiveness of GOTH is such that LRTDP+GOTH can solve even the ﬁve hardest problems of Blocksworld, which LRTDP+hF F could not. Figure 3 provides the big picture of the comparison. For each problem we tried, it contains a point whose coordinates are the logarithms of the amount of time/memory that LRTDP+GOTH and LRTDP+hF F took to solve that problem. Thus, points that lie below the Y = X line correspond to problems on which LRTDP+GOTH did better according to the respective criterion. The axes of the time plot of Figure 3 extend to log2 (86400), the logarithm of the time cutoff (86400s, i.e. 24 hours) that we used. Similarly, the axes of the memory plot reach log2 (10000000), the number of memoized states/basis functions at which the hash tables where they are stored become too inefﬁcient to allow a problem to be solved within the 86400s time limit. Thus, the points that lie on the extreme right or top of these plots denote problems that could not be solved under the guidance of at least one of the two heuristics. Overall, the time plot shows that, while GOTH ties or is slightly beaten by hF F on Drive and smaller problems of other domains, it enjoys a comfortable advantage on most large problems. In terms of memory, this advantage extends to most medium-sized and small problems as well, and sometimes translates into a qualitative difference, allowing GOTH to handle problems that hF F can’t. Why does GOTH’s and hF F ’s comparative performance differ from domain to domain? For an insight, refer to Table 1. It displays the ratio of the number of states explored by LRTDP+hF F to the number explored by LRTDP+GOTH, averaged over the problems that could be solved by both planners in each domain. Thus, these numbers reﬂect the relative informativeness of the heuristics. Note the important difference between the data in this chart and memory usage as presented on the graphs: the information in the table disregards memory consumption due to the heuris-

101

16
LOG2(LRTDP+GOTH TIME)

MS
LOG2(LRTDP+GOTH MEMORY)

MS 20 TTW EBW 15 EL DR BW 10

14 12 10 8 6 4 2 0 0

TTW EBW EL DR BW

5

2

4 6 8 10 12 LOG2(LRTDP+hFF TIME)

14

16

0 0

5

10 15 LOG2(LRTDP+hFF MEMORY)

20

Figure 3: The big picture: GOTH provides a signiﬁcant advantage on large problems. (Note that the axes are on the Log scale.)
TIME IN SECONDS
10000 GOTH/NO GEN. 8000 6000 4000 2000 0 1 2 3 4 5 6 7 8 MACHINE SHOP PROBLEM # 9 10 GOTH

Figure 4: GOTH is much faster with generalization than without. EBW 2.07 EL 4.18 TTW 1.71 DR 1.00 MS 14.40 BW 7.72

Table 1: Average ratio of the number of states memoized by
LRTDP under the guidance of hF F to the number under GOTH across each test domain. The bigger these numbers, the more memory GOTH saves the MDP solver compared to hF F .

tics, thereby separating the description of heuristics’ informativeness from a characterization of their efﬁciency. Associating the data in the table with the relative speeds of LRTDP+hF F and LRTDP+GOTH on the test domains reveals a clear trend; the size of LRTDP+GOTH’s speed advantage is strongly correlated with its memory advantage, and hence with its advantage in informativeness. In particular, GOTH’s superiority in informativeness is not always sufﬁcient to compensate for its computation cost. Indeed, the 1.71× average reduction (compared to hF F ) in the number of explored states on Triangle Tireworld is barely enough to make good the time spent on deterministic planning (even with generalization). In contrast, on domains like Blocksworld, where GOTH causes LRTDP to visit many times fewer states than hF F , LRTDP+GOTH consistently solves the problems much faster. Beneﬁt of Generalization. A central hypothesis of this paper is that generalization is vital for making GOTH computationally feasible. To test it and measure the importance of basis functions for GOTH’s operation, we ran a version of GOTH with generalization turned off on several domains, i.e. with the classical planner being invoked from every state passed to GOTH for evaluation. (As an aside, note that this is similar to the strategy of FF-Replan, with the fundamental difference that GOTH’s state values are eventually overridden by the decision-theoretic training process

of LRTDP. We explore the relationship between FF-Replan and GOTH further in the next section.) As expected, GOTH without generalization proved to be vastly slower than full GOTH. For instance, on Machine Shop LRTDP+GOTH with generalization turned off is approximately 30-40 times slower (Figure 4) by problem 10, and the gap is growing at an alarming rate, implying that without our generalization technique the speedup over hF F would not have been possible at all. On domains with implicit dead ends, e.g. Exploding Blocks World, the difference is even more dramatic, reaching over two orders of magnitude. Furthermore, at least on the relatively small problems on which we managed to run LRTDP+GOTH without generalization, we found the quality of policies (measured by the average plan length) yielded by generalized GOTH to be typically better than with generalization off. This result is somewhat unexpected, since generalization is an additional layer of approximation on top of determinizing the domain. We attribute this phenomenon to our averaging weight update strategy. As pointed out earlier, the weight of a basis function (i.e., the length of a plan, in the case of nongeneralized GOTH) from any single classical planner invocation may not be reﬂective of the basis function’s quality, and non-generalized GOTH will suffer from such noise more than regular GOTH. While we don’t know if the trend holds on the largest problems of most domains we tried, even if it is reversed the slowness of GOTH without generalization makes its use unjustiﬁable in practice. One may wonder whether generalization can also beneﬁt hF F the way it helped GOTH. While we haven’t conducted experiments to verify this, we believe the answer is no. Unlike full deterministic plan construction, ﬁnding a relaxed plan sought by hF F is much easier and faster. Considering that the generalization mechanism involves iterating over many of the available basis functions to evaluate a state, any savings that may result from avoiding hF F ’s relaxed plan computation will be negated by this iteration. Computational Proﬁle. An interesting aspect of GOTH’s modus operandi is the fraction of the computational resources an MDP solver uses that is due to GOTH. E.g., across the Machine Shop domain, LRTDP+GOTH spends 75-90% of the time in heuristic computation, whereas LRTDP+hF F only 8-17%. Thus, GOTH is computation-

102

100

Discussion
ReTrASE LRTDP+GOTH

SUCCESS RATE

80 60 40 20 0 1 2 3 4

5 6 7 8 9 10 11 12 13 14 ELEVATORS PROBLEM #

15

Figure 5: LRTDP+GOTH vastly outperforms ReTrASE on Elevators.

ally much heavier but causes LRTDP to spend drastically less time exploring the state space. Comparison against ReTrASE. Superﬁcially, ReTrASE extracts and uses basis functions in a way similar to GOTH. The major difference lies in the fact that ReTrASE tries to learn weights for the basis functions, whereas GOTH, being only a heuristic, employs basis functions to initialize state values and lets a conventional MDP solver improve on these values. In practice, this discrepancy translates to ReTrASE’s learning procedure providing very few quality guarantees. While it is very memory-efﬁcient on many hard problems, the solutions are poor on some domains with rather simple structure, e.g. Elevators from IPPC-06 (Kolobov, Mausam, and Weld 2009). In contrast, GOTH admits the use of conventional MDP solvers with strong theoretical machinery, making the outcome of its application more predictable. In particular, LRTDP+GOTH achieves a 100% success rate on all 15 Elevators problems (Figure 5) and takes at most 5 minutes per problem. This is not to say, however, that LRTDP+GOTH generally outmatches ReTrASE. For example, while LRTDP+GOTH achieves a 100% success rate on the ﬁrst 8 problems of Triangle Tire, ReTrASE performs equally well on the ﬁrst 8 problems but, unlike LRTDP+GOTH, can also solve problems 9 and 10. Thus, GOTH’s use of basis functions yields qualitatively different results than ReTrASE’s. Comparison against FF-Replan. One can also ﬁnd similarities between the techniques used by GOTH and FF-Replan. Indeed, both employ deterministic planners, FF-Replan — for action selection directly, while GOTH — for state evaluation. One key difference again lies in the fact that GOTH is not a complete planner, and lets a dedicated MDP solver correct its judgment. As a consequence, even though GOTH per se ignores probabilistic information in the domain, probabilities are (or can be) nonetheless taken into account during the solver’s search for a policy. FF-Replan, on the other hand, ignores them entirely. Due to this discrepancy, performance of FF-Replan and a planner guided by GOTH is typically vastly distinct. For instance, FF-Replan is faster than most decision-theoretic planners. On the other hand, FF-Replan has difﬁculty dealing with probabilistic subtleties and is known to come up with low success rate policies (Little and Thiebaux 2007) on domains that contain them, e.g., Triangle Tireworld. LRTDP+GOTH can handle such domains much better, as our experiments demonstrate. We conclude by stressing that, since GOTH is not a full planner, any performance comparison between it and various MDP solvers is inconclusive without the speciﬁcation of and highly dependent upon the planner that uses GOTH.

Promise shown by GOTH indicates several directions for further development. The experiments have demonstrated that GOTH generally performs well but its advantage in informativeness isn’t always sufﬁcient to secure an advantage in speed. GOTH’s speed, in turn, depends critically on how fast the deterministic planners from its portfolio are on the deterministic version of the domain at hand. Therefore, one way this issue can be alleviated is by adding more classical planners to the portfolio and launching them in parallel in the hope that at least one will be able to cope quickly with the given domain. Of course, this method may backﬁre when the number of employed classical planners exceeds the number of cores on the machine where the MDP solver is running, since the planners will start contending for resources. Nonetheless, up to that limit, increasing the portfolio size should only help, and a prominent candidate for inclusion is LAMA (Richter, Helmert, and Westphal 2008), the winner of the deterministic track of IPC-2008. In addition, using a reasonably-sized portfolio of planners may help reduce the variance of the time it takes to arrive at a heuristic estimate. Another direction is experimenting with domain determinizations GOTH could rely on. One alternative is proposed by the authors of HMDPP (Keyder and Geffner 2008) and described in Related Work. Its use could improve GOTH’s informativeness further, and possibly also ease the task of the classical planners provided that the determinization avoids enumerating all outcomes of every action without signiﬁcant losses in solution quality. An entirely different set of ideas suggested by GOTH concerns applicability of generalization in other planning algorithms. We ﬁrmly believe that generalization has the ability to enhance many existing probabilistic planning techniques as well as inspire new ones. As an example, note that FF-Replan could beneﬁt from generalization in the following way. It could extract basis functions from deterministic plans it is producing while trying to reach the goal and store each of them along with their weight and the last action regressed before obtaining that particular basis function. Upon encountering a state subsumed by at least one of the known basis functions, “generalized FF-Replan” would select the action corresponding to the basis function with the smallest weight. Besides an accompanying speed boost, which is a minor point in the case of FF-Replan since it is very fast as is, FF-Replan’s robustness could be greatly improved, since this way its action selection would be informed by several trajectories from the state to the goal, as opposed to just one. Employed analogously, basis functions could speed up FFHOP (Yoon et al. 2008), an MDP solver that has great potential but is somewhat slow in its current form. In fact, it appears that virtually any algorithm for solving MDPs could have its convergence accelerated if it regresses the trajectories found during policy search and carries over information from well explored parts of the state space to the weakly probed ones with the help of basis functions. We hope to verify this conjecture in the future.

Related Work
The use of determinization for solving MDPs was inspired by advances in classical planning, most notably the FF

103

solver (Hoffman and Nebel 2001). The practicality of the new technique was demonstrated by FF-Replan (Yoon, Fern, and Givan 2007) that used the FF planner on an MDP determinization for direct selection of an action to execute in a given state. More recent planners to employ determinization that are, in contrast to FF-Replan, successful at dealing with probabilistically interesting problems include RFF-RG/BG (Teichteil-Koenigsbuch, Infantes, and Kuter 2008). Unlike GOTH, they normally use deterministic planners to learn the state or action values, not just to initialize their values heuristically. As a consequence, they invoke FF many more times than we do. This forces them to avoid all-outcome determinization as invoking FF would be too costly otherwise. In spirit, GOTH’s strategy of extracting useful state information in the form of basis functions is related to explanation-based learning (EBL) (C. Knoblock and Etzioni 1991). However, EBL systems suffer from accumulating too much of such information, whereas GOTH doesn’t. To a large degree, the FF planner owes its performance to hF F (Hoffman and Nebel 2001). LRTDP (Bonet and Geffner 2003) and HMDPP (Keyder and Geffner 2008) adopted this heuristic with no modiﬁcations as well. In particular, HMDPP runs hF F on a “self-loop determinization” of an MDP, thereby forcing hF F ’s estimates to take into account some of the problem’s probabilistic information. Several algorithms generate basis functions by regression like we do, (Gretton and Thiebaux 2004), (Sanner and Boutilier 2006), and (Kolobov, Mausam, and Weld 2009) to name a few. However, the role of basis functions in them is entirely different. In these methods, basis functions serve to map the planning problems to smaller parameter spaces consisting of basis function weights. Parameter learning in such transformed spaces is usually approximate and gives few theoretical guarantees (see, for instance, (Kolobov, Mausam, and Weld 2009)). In GOTH, basis functions are used to generalize heuristic values over multiple states and thereby to avoid invoking the classical planner too many times. Importantly, however, the parameter space in which learning takes place is unchanged — it is still the set of state values. We can therefore use conventional techniques like LRTDP in conjunction with GOTH that give substantial predictability of the solution quality. GOTH achieves the reduction in the number of required parameters through the increased informativeness of initial heuristic estimates, not through parameter space transformation.

that GOTH outperforms hF F in time and memory on ﬁve out of six domains. We also demonstrate generalization to be the key idea enabling GOTH to compete with hF F in terms of speed. We believe that GOTH’s notion of generalization has considerable potential to improve other planning techniques as well. Acknowledgments. We would like to thank Rao Kambhampati, William Cushing, the anonymous reviewers, and our colleagues at the University of Washington AI group for their insightful comments. This work was supported by ONR grants N000140610147 and N000140910051 and the WRF/TJ Cable Professorship.

References
Bonet, B., and Geffner, H. 2003. Labeled RTDP: Improving the convergence of real-time dynamic programming. In ICAPS’03, 12– 21. Bonet, B., and Geffner, H. 2005. mGPT: A probabilistic planner based on heuristic search. Journal of Artiﬁcial Intelligence Research 24:933–944. C. Knoblock, S. M., and Etzioni, O. 1991. Integrating abstraction and explanation-based learning in PRODIGY. In Ninth National Conference on Artiﬁcial Intelligence. Forgy, C. 1982. Rete: A fast algorithm for the many pattern/many object pattern match problem. In Artiﬁcial Intelligence, volume 19, 17–37. Gerevini, A.; Saetti, A.; and Serina, I. 2003. Planning through stochastic local search and temporal action graphs. Journal of Artiﬁcial Intelligence Research 20:239–290. Gretton, C., and Thiebaux, S. 2004. Exploiting ﬁrst-order regression in inductive policy selection. In UAI’04. Hansen, E., and Zilberstein, S. 2001. LAO*: A heuristic search algorithm that ﬁnds solutions with loops. In Artiﬁcial Intelligence, 129(1–2):35–62. Hoffman, J., and Nebel, B. 2001. The FF planning system: Fast plan generation through heuristic search. Journal of Artiﬁcial Intelligence Research 14:253–302. Keyder, E., and Geffner, H. 2008. The HMDPP planner for planning with probabilities. In Sixth International Planning Competition at ICAPS’08. Kolobov, A.; Mausam; and Weld, D. 2009. ReTrASE: Integrating paradigms for approximate probabilistic planning. In IJCAI’09. Kolobov, A.; Mausam; and Weld, D. 2010. SixthSense: Fast and reliable recognition of dead ends in MDPs. In submission. Little, I., and Thiebaux, S. 2007. Probabilistic planning vs. replanning. In ICAPS Workshop on IPC: Past, Present and Future. Mausam; Bertoli, P.; and Weld, D. 2007. A hybridized planner for stochastic domains. In IJCAI’07. Richter, S.; Helmert, M.; and Westphal, M. 2008. Landmarks revisited. In AAAI’08. Sanner, S., and Boutilier, C. 2006. Practical linear valueapproximation techniques for ﬁrst-order MDPs. In UAI’06. Teichteil-Koenigsbuch, F.; Infantes, G.; and Kuter, U. 2008. RFF: A robust, FF-based MDP planning algorithm for generating policies with low probability of failure. In Sixth International Planning Competition at ICAPS’08. Yoon, S.; Fern, A.; Kambhampati, S.; and Givan, R. 2008. Probabilistic planning via determinization in hindsight. In AAAI’08. Yoon, S.; Fern, A.; and Givan, R. 2007. FF-Replan: A baseline for probabilistic planning. In ICAPS’07, 352–359.

Conclusion
We have proposed GOTH, a new heuristic that uses full-ﬂedged deterministic planners to solve MDP determinizations. Although invoking a classical solver naively is too expensive to be practical, we show that one may amortize this cost by generalizing the resulting heuristic values to cover many states. When a deterministic trajectory to the goal is found, GOTH regresses the trajectory to calculate basis functions summarizing where such a trajectory is feasible. GOTH’s use of basis functions greatly reduces the number of times the deterministic planner is called and renders our idea practical. While, like hF F , the resulting heuristic is inadmissible, it usually gives more informative state value estimates than hF F and provides signiﬁcant memory savings to the MDP solvers. The experiments show

104


Proceedings of the Twentieth International Conference on Automated Planning and Scheduling (ICAPS 2010)

Handling Goal Utility Dependencies in a Satisﬁability Framework
Richard Russell and Sean Holden
Computer Laboratory, University of Cambridge 15 J J Thomson Avenue, Cambridge, CB3 0FD, UK {Richard.Russell, Sean.Holden}@cl.cam.ac.uk

Abstract
Goal utility dependencies arise when the utility of achieving a goal depends on the other goals that are achieved with it. This complicates the planning procedure because achieving a new goal can potentially alter the utilities of all the other goals currently achieved. In this paper, we present an encoding procedure that enables general-purpose Max-SAT solvers to be used to solve planning problems with goal utility dependencies. We compare this approach to one using integer programming via an empirical evaluation using benchmark problems from past international planning competitions. Our results indicate that this approach is competitive and sometimes more successful than an integer programming one – solving two to three times more subproblems in some domains, while being outperformed by only a signiﬁcantly smaller margin in others.

Introduction
In a classical planning problem, valid plans must achieve every goal; however, when faced with limited resources, it is often useful to relax this constraint and allow the planner to make a trade-off between the beneﬁt and cost of achieving a set of goals. Such planning problems are often called partial satisfaction or oversubscription problems. There is a growing body of research concerning how to utilize concepts of utility and preference from decision theory in the solution of such problems. This has produced a renewed interest in modeling problems as integer programs due to their facility for explicitly expressing an optimization function over solutions. Despite integer programming (IP) lagging behind satisﬁability in performance, the possibility of a satisﬁability approach to partial satisfaction problems in classical planning has largely been neglected. In previous years, satisﬁability approaches to planning have enjoyed much success: in the 4th and 5th International Planning Competition (IPC) S ATPLAN (Kautz and Selman 1999; Kautz, Selman, and Hoffmann 2006) achieved ﬁrst and joint ﬁrst prizes respectively for optimal planning in propositional domains. In this context, an optimal plan is one with the smallest number of discrete time steps, often referred to as the plan’s makespan. This notion of optimality is not a particularly natural one; instead IPC-6 adopts a
Copyright c 2010, Association for the Advancement of Artiﬁcial Intelligence (www.aaai.org). All rights reserved.

collection of different metrics for optimization: number of actions, total action cost and net beneﬁt, where the net beneﬁt of a plan is the total utility of the goals achieved minus the cost of the executed actions. This raises the question of how the total utility of a set of goals should be deﬁned. The partial satisfaction planning (PSP) net beneﬁt metric (van den Briel et al. 2004) assumes that each goal has an individual utility, and the total utility of a set of goals achieved by a plan can be expressed simply as the sum of their individual utilities. This particular model is worth studying because it is conceptually simple to state but can express a variety of interesting problems: the class of Simple Preferences from PDDL3 – a recent version of the de facto standard for expressing planning problems in the AI community – can be reduced to PSP (Benton, Do, and Kambhampati 2009). There are scenarios where the utility of achieving a single goal depends upon which other goals are co-achieved. One such example arises in the IPC Rovers domain where it seems desirable to achieve complementary goals, which give good scientiﬁc coverage. For example, the utility of taking an image and a rock sample from a single site should be greater than the sum of the utilities of achieving either of those tasks in isolation. Groups of goals do not always interact positively, and there are scenarios where jointly achieving two or more goals has a reduced utility over achieving any one of them in isolation. For a purchasing problem, the agent may want a single set of chairs, but purchasing more than one set has an adverse effect: the extra sets impair movement and introduce additional hazards through overcrowding, which the agent would rather avoid. Do et al. (2007) described these types of problems as having goal utility dependencies, and they presented a systematic approach for handling them using the Generalized Additive Independence (GAI) model of utility and integer programming. Their I PUD planner ﬁnds solutions with maximum net beneﬁt for a bounded makespan horizon, but plans may exist with larger makespans that have a greater net beneﬁt. Thus, it seems that integer programming has received renewed interest for this type of planning because of its facility for explicitly expressing an optimization function. There has been some work on handling preferences in SAT: S AT-

145

PLAN has been extended to minimize the cost of executed actions in planning within a bounded horizon (Giunchiglia and Maratea 2007). In principle, it should be possible to extend this to solve PSP net beneﬁt problems. However, maximum satisﬁability (Max-SAT), in particular its weighted variants, also offers a facility for explicitly deﬁning an optimization function in a similar manner to integer programming. Max-SAT is the optimization variant of SAT. The problem is to ﬁnd a truth assignment to variables that maximizes the number of satisﬁed clauses. Further variations can be made on the problem, and one such variation that is of particular interest to us is the Weighted Partial Max-SAT problem (WPMax-SAT). These problems can contain clauses of two types: hard or soft. For our purposes, each soft clause has a non-negative integer weight which is its violation cost. The WPMax-SAT problem is to ﬁnd a truth assignment to variables that satisﬁes all hard clauses and maximizes the sum of the weights of the satisﬁed soft clauses. To our knowledge a system for handling preferences using general-purpose WPMax-SAT solvers has not been explored, nor has a satisﬁability approach to handling goal utility preferences been investigated. In this paper we develop these ideas. Our main contributions in this paper are:

combination of goals we could achieve. In the worst case, this will require space exponential in the number of goals to describe u; however, we can achieve a more compact representation if we assume that u can be factorized in some way. The Generalized Additive Independence (GAI) model (Bacchus and Grove 1995) provides one such method for decomposing a utility function and is used by Do et al. (2007) in their framework for handling goal utility dependencies. Let us split G into k, not necessarily disjoint, nonempty subsets G1 , . . . , Gk such that i=1,...,k Gi = G. The utility function u has an additive decomposition over G1 , . . . , Gk if u can be expressed as
k

u(1G ) = S
i=1

fi (1Gi ∩S ) Gi

(1)

• An encoding scheme for representing PSP net beneﬁt problems with goal utility dependencies in WPMax-SAT together with a technical extension, which we call MS ATPLAN, to S ATPLAN that implements this using a generalpurpose Max-SAT solver. • A thorough empirical comparison between MS ATPLAN and I PUD, where we ﬁnd that MS ATPLAN has competitive and often better performance than its IP counterpart.

for a collection of k functions fi : B|Gi | → N0 . Hopefully, k and the size of each Gi will be sufﬁciently small to allow us to represent the function using less space than a single tabular representation of u over |G|, thus leading to a more practical encoding. The utility of a set of goals achieved by a plan is only one aspect of its quality; there are often many different plans that will achieve a particular set of goals. In order to distinguish between them, we should include their execution cost in our measure of plan quality. For each action a ∈ A we associate a cost c(a) ∈ N0 for executing that action. By writing the set of goals achieved by a plan P as Goals(P ), we can now precisely deﬁne the most preferred plan P as the plan that maximizes the net beneﬁt:
m

P =

argmax
valid plans P =(a1 ,...,am )

u 1G Goals(P ) −

c(ai ) .
i=1

(2)

Encoding Utilities
A classical planning problem is described by a 4-tuple F, I, G, A where F is a set of predicate symbols, I is a set of ground predicates that are true in the initial state, G is a set of ground predicates that must be true in the goal state and A is a set of actions. Each action a ∈ A has a precondition set Pre(a) of ground predicates that must all be true for a to be applicable; it also has a set Add(a) of add effects and a set Del(a) of delete effects that contain ground predicates which are made true and false respectively if a is executed. We deﬁne a plan P as an ordered sequence of actions (a1 , . . . , am ) which achieve a subset of the ground predicates in G when executed in order from the initial state in which only the predicates in I are true. For a nonempty set G ⊆ G of N ground predicates with indexed elements {g1 , . . . , gN } we will use pseudo-Boolean functions of the form f : BN → N0 where B = {1, 0} and N0 = {0, 1, 2, . . . }. For a subset S ⊆ G of goals achieved by a particular plan, we deﬁne a vector 1G = (x1 , . . . , xN ) S such that 1 if gi ∈ S xi = 0 otherwise. For a planning problem, we assume we are given a function u : B|G| → N0 that speciﬁes a utility for each possible

Weighted Partial Max-SAT (WPMax-SAT)
WPMax-SAT is the variation of Max-SAT that we use in our encodings. A weighted clause is a disjunction of literals 1 , . . . , q with an associated weight w ∈ N0 ∪ { }, which we write as (
1

∨ ··· ∨
w

q) .

(3)

Weighted clauses are either hard or soft. A clause is hard if its weight is the special element ; all other clauses are soft. Let Φ be a conjunction of weighted clauses. A complete truth assignment to the variables in Φ gives each variable a truth value. A model for Φ is a complete truth assignment to the variables in Φ that satisﬁes all hard clauses. The cost of a model for Φ is the sum of the weights of the falsiﬁed clauses in Φ produced by that truth assignment. The WPMax-SAT problem is to ﬁnd a model of minimum cost for Φ. If Φ consists of only soft weighted clauses then we have the weighted Max-SAT problem; if all clauses are soft with weight 1 then we have the Max-SAT problem.

Plan Encoding
We extend the ‘thin-gp’ encoding from S ATPLAN (Kautz, Selman, and Hoffmann 2006) to create a formula ϕT in h

146

propositional logic with the property that a satisfying assignment to it allows us to extract a plan with a makespan of at most T from the truth assignment; however, since all goals are soft, we do not include the clauses that force each goal to be true at level T , and we add additional axioms, not included in the original ‘thin-gp’ encoding, that ensure a goal is not achieved by the extracted plan if it is false at level T . Algorithm 1: Encoding the planning graph (ϕT ). h
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29

Result: ϕT encoding the planning problem. h begin ϕ ← true foreach ρ ∈ I do ϕ ← ϕ ∧ (Vpred (ρ, 0)) for t ← 1 to T do foreach a ∈ A applicable at level t do foreach ρ ∈ Pre(a) do ϕ ← ϕ ∧ (¬Vact (a, t) ∨ Vpred (ρ, t − 1)) foreach ρ ∈ F reachable at level t do C ← ¬Vpred (ρ, t) foreach a ∈ A applicable at level t such that ρ ∈ Add(a) do C ← C ∨ Vact (a, t) ϕ←ϕ∧C foreach a1 , a2 ∈ A applicable at level t do if Mutex(a1 ,a2 ,t) then ϕ ← ϕ ∧ (¬Vact (a1 , t) ∨ ¬Vact (a2 , t)) foreach ρ1 , ρ2 ∈ F reachable at level t do if Mutex(ρ1 ,ρ2 ,t) then ϕ ← ϕ ∧ (¬Vpred (ρ1 , t) ∨ ¬Vpred (ρ2 , t)) foreach g ∈ G reachable at level t do foreach a ∈ A applicable at level t such that g ∈ Add(a) do ϕ ← ϕ ∧ (Vpred (g, t) ∨ ¬Vact (a, t)) if g is reachable at level t − 1 then C ← Vpred (g, t) ∨ ¬Vpred (g, t − 1) foreach a ∈ A applicable at level t such that g ∈ Del(a) do C ← C ∨ Vact (a, t) ϕ←ϕ∧C ϕT ← ϕ h end

A satisfying truth assignment, S, to the variables in ϕT h corresponds to a valid plan Plan(S); however, it is no longer necessary for a valid plan to achieve all the goals in G. For each goal predicate ρi ∈ G, if ρi is in the planning graph at level T then the variable Vpred (ρi , T ) occurs in ϕT and we h say that ρi is coded for as a goal in ϕT . If ρi has been coded h for as a goal then ρi is achieved by executing Plan(S) from the initial state iff S[Vpred (ρi , T )] is true; in all other cases, including those for which ρi has not been coded for as a goal, Plan(S) does not achieve ρi . The ‘only if’ condition is ensured by the addition of the following axiom to the encoding: ⎛ ⎞ ⎜ ¬Vpred (g, t) ⇒ ⎜¬Vpred (g, t − 1) ∨ ⎝ ⎟ Vact (a, t)⎟ ∧ ⎠

a∈A s.t. g∈Del(a)

¬Vact (a, t), (∀g ∈ G, 1 ≤ t ≤ T ), (4)
a∈A s.t. g∈Add(a)

which produces the clauses as described in lines 20–27 in Algorithm 1.

Optimization Function
So far, we have presented a method for creating a clausal formula ϕT in propositional logic, consisting only of hard h clauses, from which we can extract a valid plan from any satisﬁable truth assignment to that formula. In order to guide the search procedure to plans of high net beneﬁt, we need to specify an optimization function over solutions. Our approach is to construct a clausal formula ϕT in proposis tional logic, consisting only of weighted soft clauses, with the property that an optimal satisﬁable truth assignment S to the WPMax-SAT formula ΦT = ϕT ∧ ϕT gives a plan s h Plan(S ) of maximum net beneﬁt over all possible plans of makespan less than or equal to T . We assume that our utility function u has an additive decomposition over G1 , . . . , Gk as given in Equation 1. We introduce a measure which we call the residual utility resulting from a truth assignment to the arguments of a function fi in the additive decomposition of u. The residual utility is the amount of utility that we failed to secure by choosing this truth assignment over one that would maximize the utility for this factor. More precisely, let the maximum of the function be ¯ (5) fi = max fi (v).
v∈B|Gi |

A summary of the steps involved in producing this encoding can be found in Algorithm 1. Lines 3–19 are from the original ‘thin-gp’ encoding; we write A to denote A extended to include NOOP actions for each ground predicate. For more details the reader should refer to the above paper. A planning graph (Blum and Furst 1997) of makespan T is built from domain and problem PDDL ﬁles. For 0 ≤ t ≤ T , a binary variable Vpred (ρ, t) is created for each ground predicate ρ that is reachable at time step t. For 1 ≤ t ≤ T , a binary variable Vact (a, t) is created for each action a that has reachable and non-mutex preconditions at level t − 1.

→ N0 that calculates the residDeﬁne the function ri : B ual utility of a truth assignment v ∈ B|Gi | to the arguments of fi as ¯ (6) ri (v) = fi − fi (v). Using this measure, and assuming that all predicates in G are coded for as goals in ϕT , we construct ϕT such that it s h satisﬁes the property that for every complete satisﬁable assignment, S to ΦT , the following holds: 1. For each action a that is executed in Plan(S), a unique clause is violated in ϕT with weight c(a). s

|Gi |

147

2. For each Gi in the additive decomposition of u, a unique clause is violated in ϕT with weight ri (1Gi ∩S ) where S s Gi is the set of goals achieved by Plan(S). 3. No other clauses are violated. satisﬁes this property, then the sum of weights of If violated clauses for such a truth assignment S will be given by
k i=1 m

Algorithm 2: Encoding the optimization function (ϕT ). s
1 2 3 4 5

ϕT s

Result: ϕT encoding the optimization function. s begin ΩT ← { ρj ∈ G | ρj is coded for as a goal in ϕT } h ϕ ← true for t ← 1 to T do foreach action a ∈ A applicable at level t do ϕ ← ϕ ∧ (¬Vact (a, t))
c(a)

ri 1Gi ∩Goals(Plan(S)) + Gi

c(ai ),
i=1

(7)

6 7 8 9 10 11

where Plan(S) = (a1 , . . . , am ). An optimal WPMax-SAT solver applied to ΦT will ﬁnd the truth assignment S that minimizes this quantity which is equivalent to maximizing its negative. Therefore, S is given by
k m

S = argmax

(8) where the ai and m are dependent on S such that Plan(S) = (a1 , . . . , am ). Note that the quantity being maximized is a form of Equation 2; thus, a WPMax-SAT solver applied to ΦT will ﬁnd a valid plan that is optimal up to the makespan T with regard to maximizing the net beneﬁt metric.

Satisﬁable T.A. i=1 S to ΦT

fi 1Gi ∩Goals(Plan(S)) − Gi

c(ai ) ,
i=1

12 13 14

for i ← 1 to k do foreach v ∈ B|Gi | do π + ← {ρj ∈ Gi | vj = 1} π − ← {ρj ∈ Gi | vj = 0} if MutexFree(π + ,T ) and π + ⊆ ΩT then L ← {¬Vpred (ρ, T ) | ρ ∈ π + } L ← L ∪ {Vpred (ρ, T ) | ρ ∈ π − ∩ ΩT } if L = ∅ then ϕ←ϕ∧
∈L

15

ri (v)

Encoding the Optimization Function
We have seen that if ϕT satisﬁes the property we outlined s above, then the plans produced maximize net beneﬁt for a ﬁxed makespan. Now we discuss the details of how such a formula is constructed according to our procedure shown in Algorithm 2. The ﬁrst part of the property is encoded in lines 4–6 where a clause is added to ϕT for each action that is applicable at s each level up to the makespan T . If an action a is executed at level t in a plan extracted from a truth assignment, then Vact (a, t) is necessarily true from the deﬁnition of ϕT . Conh sequently, the clause (¬Vact (a, t)) with weight c(a) is violated and c(a) is added to the cost of the truth assignment. If the action is not executed, then Vact (a, t) is false and its corresponding clause is satisﬁed and makes no contribution to the cost of the assignment. The second part of the property is ensured by lines 7– 17; the objective is to produce, for each Gi and each truth assignment to predicates in Gi , a soft clause, weighted by the residual utility, that is violated iff the predicates in Gi take on that truth assignment. Our procedure is made more complicated by accounting for situations where one or more predicates in G are not coded for as goals in ϕT . h If a particular Gi is being processed, for each truth assignment, the predicates in Gi are split into two sets, π + and π − , depending on whether the predicate is assigned true or false respectively (lines 9–10). We then check to see if the truth assignment might be possible on line 11 by checking if any pair of predicates in π + is known to be mutex at the ﬁnal level of the plan. If this is true then the truth assignment will never satisfy ϕT so there is no need to add a clause for this h particular truth assignment to Gi to ϕT . s

16 17

ϕT ← ϕ s end

If at least one predicate in π + is not coded for as a goal, then this tells us that this predicate cannot be achieved by any plan of makespan less than or equal to T ; thus, this truth assignment and its corresponding clause should be ignored. This is the reason for the check π + ⊆ ΩT on line 11. At lines 12 and 13 we gather the set of literals for the clause. We negate variables corresponding to predicates in π + and leave as positive literals the variables corresponding to predicates in π − ∩ ΩT . If the truth assignment is made, then all literals will be false and the clause will be violated. Notice how we exclude any predicates that are in π − \ ΩT because they are unreachable at the ﬁnal level and cannot be achieved by any plan of makespan less than or equal to T , consequently they are ﬁxed to false. The check at line 14 handles the special case where the truth assignment assigns false to all predicates in Gi and none of these predicates are coded for as goals in ϕT . This results in an empty clause that h is always violated; therefore, we need not include it in the encoding since it will not affect the minimization. Finally, at line 15 the clause is added with weight set to the residual utility of the truth assignment to the predicates in Gi . We implemented this procedure on top of the S ATPLAN 06 system. We modiﬁed the parser and lexer to read in a speciﬁcation of action costs and a description of the utility function. To represent the utility function we use a tree-like structure called a UCP-net1 (Boutilier, Bacchus, and BrafWe ignore the ceteris paribus condition that ensures the dominance property at each node because we compile the function to WPMax-SAT where it is not exploited by the solver.
1

148

Figure 1: Comparison of MS ATPLAN with I PUD/SYM on the number of subproblems solved as each system is given more time. Each point shows the mean number of subproblems solved within the corresponding time limit. Error bars show ±σ, calculated over three runs. A lack of an error bar indicates that there was no observed variance in that measurement. man 2001). Each node in this tree represents the value of a single goal predicate from G. If there is a directed link from node Y to node X then Y is a parent of X, and we denote the set of parents of a node X as Parents(X). Each node X also contains a conditional preference table which we specialize to a tabular representation of a pseudo-Boolean function fX : B|Parents(X)|+1 → N0 since all variables in the tree are boolean-valued. fX represents X’s contribution to the utility of a plan dependent on its value and those of its parents. ﬁnd values that tended to allow valid plans of increasing net beneﬁt as the makespan was increased from 1 to 10. If the action costs are too high or the utilities too low it precludes the existence of any nonempty plan with positive net beneﬁt; the optimal plan would be empty in these cases. We do not use the original I PUD system because it uses a commercial linear program solver called CPLEX 10.02 , which we did not have access to; instead, we implemented I PUD’s encoding scheme by extending the 1SC encoding3 of IPP LAN (van den Briel, Vossen, and Kambhampati 2008) and modifying it to use an open-source mixed integer program solver SYMPHONY 5.1 (Ralphs and Guzelsoy 2005). We refer to this implementation as I PUD/SYM to avoid ambiguity. We believe this remains a reasonably fair test as we do not use a commercial WPMax-SAT solver and the algorithms for SYMPHONY are published and open for inspection. MS ATPLAN uses MiniMaxSat 1.0 (Heras, Larrosa, and Oliveras 2008) to solve the WPMax-SAT encodings. MiniMaxSat was chosen because of its strong performance across domains in the Max-SAT-2008 evaluation. Since all goals are soft, a (possibly empty) plan exists at every makespan, and consequently it is not very interesting to search for the plan with smallest makespan. Instead, we split each problem up into subproblems parameterized by a makespan variable d. Each subproblem is to ﬁnd a plan of makespan d that solves the original problem with optimal net beneﬁt over all other plans of makespan d. For each problem in a domain benchmark, we derive subproblems for d = 1, . . . , 10. Each planning system is given 30 minutes to solve each subproblem, and is aborted if it fails to do so. In summary, each run of our experiment consists of generhttp://www.ilog.com/products/cplex We use the 1SC encoding instead of the G1SC one used in Do et al.’s original paper because it allows the same amount of parallelism as the SAT-based encoding that MS ATPLAN extends.
3 2

Experimental Results
We compared our system MS ATPLAN with I PUD using a one state change (1SC) encoding over a collection of problems derived from past International Planning Competition (IPC) benchmarks: DriverLog, Depot, ZenoTravel and Rovers from IPC3; and Truck and Pathways from IPC4. We wrote a Java program to parse untyped STRIPS problems and attach randomly generated action costs and utility functions over goals. This process is described as follows. For each action in a domain, a cost is generated randomly according to a discrete uniform distribution over the values {x ∈ N | 1 ≤ x ≤ 30}. For each problem, a random utility function is generated in two stages. Firstly, a DAG with a restriction on heuristic induced width is randomly generated according to a method that is used to generate random Bayesian networks (Ide et al. 2004). Given this DAG, a conditional preference table (CPT) is generated for each node. For each truth assignment T for a node X and its parents, if T [X] is false then an entry of 0 is made in the CPT for that truth assignment; otherwise, a value is randomly generated according to a discrete uniform distribution over the values {x ∈ N | 100 ≤ x ≤ 200}, and this is entered in the CPT for the truth assignment T . The numbers in these ranges are somewhat arbitrary; they were selected by experimenting to

149

Figure 2: Comparison of the successful search depth between MS ATPLAN and I PUD/SYM over six problem domains taken from IPC-3 and IPC-4. Each point shows the mean number of subproblems, of a particular makespan, that were solved by each system. Error bars show ±σ, which is calculated over the three runs. A lack of an error bar indicates that there was no observed variance in that measurement. ating a random utility tree and action costs for each problem in each domain, splitting each problem into 10 subproblems and attempting to solve each subproblem with both solvers. We conduct three runs using randomly generated utility trees and action costs each time. Where appropriate, we computed the sample mean and sample variance over these different runs to investigate how the utility tree and action costs affect solution times. All experiments were conducted on a Linux machine with an Intel 2.4 GHz quad core CPU (although neither program is multithreaded) and 2 GB of memory; however, we limit the memory resource available to each program to 1.5 GB to reduce paging. When examining these results, it should be noted that I PUD/SYM uses a translation step, taken from the Fast Downward Planner (Helmert 2006), that converts PDDL2.2 (Edelkamp and Hoffmann 2004) ﬁles to the SAS+ formalism (Backstrom and Nebel 1995), which is used to represent multi-valued planning tasks. Inspection of several experiments revealed that for problems 06–30 from the Pathways domains, this translation step almost always failed to complete within 30 minutes. We found that this was also the case for the original translation tool applied to the original PDDL2.2 ﬁles taken from the Pathways domain from IPC-4; the reason for this failure remains unclear. The data were used to calculate for each run, and exponentially increasing time limits, the number of subproblems solved within those time limits. The results for each time limit were then averaged over the three runs. Figure 1 shows a plot of the results. MS ATPLAN shows a clear advantage over the 1SC encoding of I PUD/SYM for the Depot and Truck domains by solving 233% and 107% more subproblems respectively. MS ATPLAN also performs very well on the Pathways domain; however, comparing this with I PUD/SYM is not possible because of a problem with the translation step as described above. I PUD/SYM solves 27%, 40%, and 2% more problems than MS ATPLAN for the DriverLog, ZenoTravel and Rovers domains respectively. How the two systems compare over the range of ﬁxed makespans can be seen in Figure 2. The percentage of subproblems that are solved drops off with an increase in makespan, as one would expect; however, the gradient of this decrease differs quite substantially between domains. For the Depot and DriverLog domains, the decrease is smooth with a reasonably consistent gradient for both systems. For the Truck and Pathways domains, there is very little decrease initially and almost all the decrease occurs within 2–4 makespans for MS ATPLAN. How each system performed on an individual problem can be seen in Figure 3. It is somewhat surprising that MS ATPLAN’s performance is maintained across the Pathways domain. For other domains the performance tends to degrade as the problem number increases, since these are considered harder problems. It is also surprising that MS ATPLAN solves a large number of subproblems from the higher problem numbers in the DriverLog domain, but not for problem numbers 04–10, which would normally be considered easier to solve.

Discussion
The leading approaches to ﬁnding an optimal solution to a WPMax-SAT problem usually involve a depth-ﬁrst branchand-bound or branch-and-cut search; the same can be said for ﬁnding an optimal solution to an integer program. These algorithms calculate an exact upper bound ub on the cost of the optimal solution, which is the cost of the best model found so far in the search, and an underestimation of best cost that can be achieved by extending the current partial assignment to a model. A branch of the search tree is pruned

150

Figure 3: Comparison of MS ATPLAN with I PUD/SYM on each problem over a total of six domains from IPC-3 and IPC-4. The height of a bar indicates the mean number of subproblems solved by that system for that problem. Error bars indicate ±σ, calculated over three runs. A lack of an error bar for a column indicates that there was no observed variance in that measurement. when its lower bound is found to be greater than or equal to ub. Soft clauses can also be promoted to hard clauses during the search if their weight is found to be greater than ub, which allows us to use this clause together with other hard clauses for efﬁcient procedures such as unit-propagation. If we incrementally increase the plan makespan and ﬁnd optimal solutions for each one, we can trivially extend an optimal solution for a makespan of d − 1 to a solution with makespan d by executing appropriate NOOP actions between layers d − 1 and d. From this, we can produce a nontrivial lower bound on the best net beneﬁt obtainable at makespan d and thus produce a nontrivial value for ub for the problem at makespan d. Hopefully, this will increase the number of pruning and promotion events, as described above, that occur early on in the branch-and-bound search. It is worth noting that these branch-and-bound searches keep track of the best solution encountered during search. This can produce a solution to a planning problem at any time – before the ﬁrst non-trivial solution is found, this would return the empty plan. In our experiments we terminated searches that lasted for longer than 30 minutes and recorded no solution. Alternatively, after 30 minutes, we could have returned the best solution found so far in the branch-and-bound search and compared this to the results obtained by a heuristic search planner; however, MiniMaxSat did not support this feature. ning as satisﬁability paradigm. Londex constraints generalize mutex links to indicate mutual exclusion across time steps, which reduces planning time in many benchmark problems (Chen, Zhao, and Zhang 2007). ∃-step semantics have been incorporated into encodings for planning as satisﬁability (Wehrle and Rintanen 2007). This style of semantics allows parallel execution of operators if at least one total ordering of them is consistent, which allows for shorter parallel plan lengths. The generalized one state change (G1SC) encoding, found in I PUD, provides this level of parallelism (van den Briel, Vossen, and Kambhampati 2008). Lifted encodings for planning as satisﬁability that allow more scope for parallelism have been investigated (Robinson et al. 2008). Although preferences are receiving an increasing amount of attention from the planning community, there has been little work examining how the planning as satisﬁability paradigm can handle preferences. S ATPLAN ( P ) handles quantitative and qualitative preferences using a custom DPLL solver that branches according to a preference order (Giunchiglia and Maratea 2007). In particular, for a problem with quantitative preferences, the value of the optimization function is encoded as a sequence of bits, and the preference order prefers higher/lower order bits to be set depending on whether the optimization function is to be maximized/minimized. Their experimental results only cover the cases where either (1) each goal is soft with a utility of 1 and there are no action costs or (2) all goals are hard and all actions have cost 1. Thus, it remains to be seen how their approach scales for optimization functions that are more ﬂexible. The heuristic search planners AltAlt and Sapa have been extended to solve PSP problems (van den Briel et al. 2004); the former heuristically selects a set of goals to plan for, and

Related Work
Using Max-SAT to model hard and soft constraints in optimization problems has been studied for Steiner trees (Jiang, Kautz, and Selman 1995), although this did not use the partial weighted Max-SAT variant, so hard constraints were modelled with very high numeric weights. There have been several recent improvements to the plan-

151

Sapa uses an A* search with a heuristic that estimates the extra net beneﬁt available from extending the current partial plan. Sapa has also been extended to handle goal utility dependencies (Do et al. 2007). Its heuristic calculation ﬁrst greedily constructs a relaxed plan that supports all reachable goals; it then encodes a problem in IP to ﬁnd the most beneﬁcial plan contained in the relaxed plan. An alternative method for selecting goals to plan for is to represent an abstracted part of the planning problem as an orienteering problem (Smith 2004). This is motivated by oversubscription planning problems relevant to the Mars rover where the cost of achieving goals depends strongly on the order in which they are achieved. The aim is to model the cost dependencies between achieving goals, but this ignores the idea of goal utility dependencies. If such goal dependencies are sufﬁciently localized so that none exist between ‘cities’ in the orienteering graph, then a system such as I PUD or MS ATPLAN might ﬁnd use in producing reward estimates for each city provided that the subproblems are small enough and the computation time constraints are sufﬁciently generous.

Concluding Remarks
We have demonstrated a system, MS ATPLAN, for solving planning problems with goal utility dependencies using an optimization variant of propositional satisﬁability, known as weighted partial Max-SAT. This system is guaranteed to produce plans that are optimal up to a given makespan. We compared our implementation against a successful integer programming based encoding, implemented as I PUD/SYM, using past benchmark problems from the International Planning Competition. Our results showed that MS ATPLAN is competitive with I PUD/SYM, solving as many as 107% and 233% more subproblems for the Truck and Depots domains; it also demonstrated consistently good performance on the Pathways domain. When I PUD/SYM outperformed MS ATPLAN in our experiments, it did so by a smaller margin: 27%, 40% and 2% more problems solved for the DriverLog, ZenoTravel and Rovers domains. We obtained our results for MS ATPLAN using a generalpurpose weighted partial Max-SAT solver to ﬁnd a plan. An area for future work is to investigate how we can specialize the algorithms used in these solvers to exploit the regular structure that is found in plan encodings.

Acknowledgements
We would like to thank Ashutosh Mahajan, Malte Helmert and Menkes van den Briel for their valuable assistance in working with various software programs mentioned in this paper. This work was supported by the UK Engineering and Physical Sciences Research Council under grant EP/P50385X/1.

References
Bacchus, F., and Grove, A. 1995. Graphical models for preference and utility. In Proc. UAI. Backstrom, C., and Nebel, B. 1995. Complexity results for SAS+ planning. Computational Intelligence 11:625–655.

Benton, J.; Do, M.; and Kambhampati, S. 2009. Anytime heuristic search for partial satisfaction planning. Artiﬁcial Intelligence 173:562–592. Blum, A., and Furst, M. 1997. Fast planning through planning graph analysis. Artiﬁcial intelligence 90:281–300. Boutilier, C.; Bacchus, F.; and Brafman, R. 2001. UCPNetworks: A directed graphical representation of conditional utilities. In Proc. UAI. Chen, Y.; Zhao, X.; and Zhang, W. 2007. Long-distance mutual exclusion for propositional planning. In Proc. IJCAI. Do, M.; Benton, J.; van den Briel, M.; and Kambhampati, S. 2007. Planning with goal utility dependencies. In Proc. IJCAI. Edelkamp, S., and Hoffmann, J. 2004. PDDL2.2: The language for the classical part of the 4th international planning competition. Technical Report 195, Universit¨ t Freiburg, Ina stitut f¨ r Informatik. u Giunchiglia, E., and Maratea, M. 2007. Planning as satisﬁability with preferences. In Proc. AAAI. Helmert, M. 2006. The fast downward planning system. JAIR 26:191–246. Heras, F.; Larrosa, J.; and Oliveras, A. 2008. MiniMaxSAT: An efﬁcient weighted Max-SAT solver. JAIR 31:1–32. Ide, J.; Cozman, F.; Ramos, F.; et al. 2004. Generating random Bayesian networks with constraints on induced width. In Proc. ECAI. Jiang, Y.; Kautz, H.; and Selman, B. 1995. Solving problems with hard and soft constraints using a stochastic algorithm for MAX-SAT. In Proc. of the Intl. Joint Workshop on Artiﬁcial Intelligence and Operations Research. Kautz, H., and Selman, B. 1999. Unifying SAT-based and graph-based planning. In Proc. IJCAI. Kautz, H.; Selman, B.; and Hoffmann, J. 2006. Satplan: Planning as satisﬁability. In Booklet of 5th IPC. Ralphs, T., and Guzelsoy, M. 2005. The SYMPHONY callable library for mixed integer programming. In Proc. of the Conf. of the INFORMS Computing Society. Robinson, N.; Gretton, C.; Pham, D.; and Sattar, A. 2008. A compact and efﬁcient SAT encoding for planning. In Proc. ICAPS. Smith, D. 2004. Choosing objectives in over-subscription planning. In Proc. ICAPS. van den Briel, M.; Sanchez, R.; Do, M.; and Kambhampati, S. 2004. Effective approaches for partial satisfaction (oversubscription) planning. In Proc. AAAI. van den Briel, M.; Vossen, T.; and Kambhampati, S. 2008. Loosely coupled formulations for automated planning: an integer programming perspective. JAIR 31:217–257. Wehrle, M., and Rintanen, J. 2007. Planning as satisﬁability with relaxed ∃-step plans. In Proc. of the Australian Joint Conf. on Artiﬁcial Intelligence.

152

